// This file is auto-generated by @hey-api/openapi-ts

export type GetHealthData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/health/';
};

export type GetHealthResponses = {
  /**
   * Object with status ok, if the server is running
   */
  200: {
    status: string;
  };
};

export type GetHealthResponse = GetHealthResponses[keyof GetHealthResponses];

export type GetApiKeyStatusData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api-key-status/';
};

export type GetApiKeyStatusResponses = {
  /**
   * API key status
   */
  200: {
    status: string;
    data: {
      token: string;
      permission: 'Read' | 'ReadAndPay' | 'Admin';
      usageLimited: boolean;
      networkLimit: Array<'Preprod' | 'Mainnet'>;
      RemainingUsageCredits: Array<{
        unit: string;
        amount: string;
      }>;
      status: 'Active' | 'Revoked';
    };
  };
};

export type GetApiKeyStatusResponse =
  GetApiKeyStatusResponses[keyof GetApiKeyStatusResponses];

export type GetWalletData = {
  body?: never;
  path?: never;
  query: {
    /**
     * The type of wallet to query
     */
    walletType: 'Selling' | 'Purchasing';
    /**
     * The id of the wallet to query
     */
    id: string;
    /**
     * Whether to include the decrypted secret in the response
     */
    includeSecret?: string;
  };
  url: '/wallet/';
};

export type GetWalletResponses = {
  /**
   * Wallet status
   */
  200: {
    status: string;
    data: {
      Secret?: {
        createdAt: string;
        updatedAt: string;
        mnemonic: string;
      };
      PendingTransaction: {
        createdAt: string;
        updatedAt: string;
        hash: string | null;
        lastCheckedAt: string | null;
      } | null;
      note: string | null;
      walletVkey: string;
      walletAddress: string;
    };
  };
};

export type GetWalletResponse = GetWalletResponses[keyof GetWalletResponses];

export type PostWalletData = {
  body?: {
    /**
     * The network the Cardano wallet will be used on
     */
    network: 'Preprod' | 'Mainnet';
  };
  path?: never;
  query?: never;
  url: '/wallet/';
};

export type PostWalletResponses = {
  /**
   * Wallet created
   */
  200: {
    walletMnemonic: string;
    walletAddress: string;
    walletVkey: string;
  };
};

export type PostWalletResponse = PostWalletResponses[keyof PostWalletResponses];

export type DeleteApiKeyData = {
  body?: {
    /**
     * The id of the API key to be (soft) deleted.
     */
    id: string;
  };
  path?: never;
  query?: never;
  url: '/api-key/';
};

export type DeleteApiKeyErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type DeleteApiKeyResponses = {
  /**
   * API key deleted
   */
  200: {
    data: {
      id: string;
      token: string;
      permission: 'Read' | 'ReadAndPay' | 'Admin';
      usageLimited: boolean;
      networkLimit: Array<'Preprod' | 'Mainnet'>;
      status: 'Active' | 'Revoked';
      deletedAt: string | null;
    };
    status: string;
  };
};

export type DeleteApiKeyResponse =
  DeleteApiKeyResponses[keyof DeleteApiKeyResponses];

export type GetApiKeyData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * The number of API keys to return
     */
    limit?: number;
    /**
     * Used to paginate through the API keys
     */
    cursorToken?: string;
  };
  url: '/api-key/';
};

export type GetApiKeyErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type GetApiKeyResponses = {
  /**
   * Api key status
   */
  200: {
    status: string;
    data: {
      ApiKeys: Array<{
        id: string;
        token: string;
        permission: 'Read' | 'ReadAndPay' | 'Admin';
        usageLimited: boolean;
        networkLimit: Array<'Preprod' | 'Mainnet'>;
        RemainingUsageCredits: Array<{
          unit: string;
          amount: string;
        }>;
        status: 'Active' | 'Revoked';
      }>;
    };
  };
};

export type GetApiKeyResponse = GetApiKeyResponses[keyof GetApiKeyResponses];

export type PatchApiKeyData = {
  body?: {
    /**
     * The id of the API key to update. Provide either id or apiKey
     */
    id: string;
    /**
     * To change the api key token
     */
    token?: string;
    /**
     * The amount of credits to add or remove from the API key. Only relevant if usageLimited is true.
     */
    UsageCreditsToAddOrRemove?: Array<{
      unit: string;
      amount: string;
    }>;
    /**
     * Whether the API key is usage limited
     */
    usageLimited?: boolean;
    /**
     * The status of the API key
     */
    status?: 'Active' | 'Revoked';
    /**
     * The networks the API key is allowed to use
     */
    networkLimit?: Array<'Preprod' | 'Mainnet'>;
  };
  path?: never;
  query?: never;
  url: '/api-key/';
};

export type PatchApiKeyErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type PatchApiKeyResponses = {
  /**
   * API key deleted
   */
  200: {
    data: {
      id: string;
      token: string;
      permission: 'Read' | 'ReadAndPay' | 'Admin';
      networkLimit: Array<'Preprod' | 'Mainnet'>;
      usageLimited: boolean;
      status: 'Active' | 'Revoked';
    };
    status: string;
  };
};

export type PatchApiKeyResponse =
  PatchApiKeyResponses[keyof PatchApiKeyResponses];

export type PostApiKeyData = {
  body?: {
    /**
     * Whether the API key is usage limited. Meaning only allowed to use the specified credits or can freely spend
     */
    usageLimited?: string;
    /**
     * The credits allowed to be used by the API key. Only relevant if usageLimited is true.
     */
    UsageCredits: Array<{
      unit: string;
      amount: string;
    }>;
    /**
     * The networks the API key is allowed to use
     */
    networkLimit?: Array<'Preprod' | 'Mainnet'>;
    /**
     * The permission of the API key
     */
    permission?: 'Read' | 'ReadAndPay' | 'Admin';
  };
  path?: never;
  query?: never;
  url: '/api-key/';
};

export type PostApiKeyErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type PostApiKeyResponses = {
  /**
   * API key deleted
   */
  200: {
    data: {
      id: string;
      token: string;
      permission: 'Read' | 'ReadAndPay' | 'Admin';
      usageLimited: boolean;
      networkLimit: Array<'Preprod' | 'Mainnet'>;
      status: 'Active' | 'Revoked';
    };
    status: string;
  };
};

export type PostApiKeyResponse = PostApiKeyResponses[keyof PostApiKeyResponses];

export type GetPaymentData = {
  body?: never;
  path?: never;
  query: {
    /**
     * The number of payments to return
     */
    limit?: number;
    /**
     * Used to paginate through the payments. If this is provided, cursorId is required
     */
    cursorId?: string;
    /**
     * The network the payments were made on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The smart contract address of the payment source
     */
    filterSmartContractAddress?: string | null;
    /**
     * Whether to include the full transaction and status history of the payments
     */
    includeHistory?: string;
  };
  url: '/payment/';
};

export type GetPaymentErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type GetPaymentResponses = {
  /**
   * Payment status
   */
  200: {
    status: string;
    data: {
      Payments: Array<{
        id: string;
        createdAt: string;
        updatedAt: string;
        blockchainIdentifier: string;
        lastCheckedAt: string | null;
        payByTime: string | null;
        submitResultTime: string;
        unlockTime: string;
        collateralReturnLovelace: string | null;
        externalDisputeUnlockTime: string;
        requestedById: string;
        resultHash: string;
        inputHash: string;
        cooldownTime: number;
        cooldownTimeOtherParty: number;
        onChainState:
          | 'FundsLocked'
          | 'FundsOrDatumInvalid'
          | 'ResultSubmitted'
          | 'RefundRequested'
          | 'Disputed'
          | 'Withdrawn'
          | 'RefundWithdrawn'
          | 'DisputedWithdrawn';
        NextAction: {
          requestedAction:
            | 'None'
            | 'Ignore'
            | 'WaitingForManualAction'
            | 'WaitingForExternalAction'
            | 'SubmitResultRequested'
            | 'SubmitResultInitiated'
            | 'WithdrawRequested'
            | 'WithdrawInitiated'
            | 'AuthorizeRefundRequested'
            | 'AuthorizeRefundInitiated';
          errorType: 'NetworkError' | 'Unknown';
          errorNote: string | null;
          resultHash: string | null;
        };
        CurrentTransaction: {
          id: string;
          createdAt: string;
          updatedAt: string;
          txHash: string | null;
        } | null;
        TransactionHistory: Array<{
          id: string;
          createdAt: string;
          updatedAt: string;
          txHash: string | null;
        }> | null;
        RequestedFunds: Array<{
          amount: string;
          unit: string;
        }>;
        WithdrawnForSeller: Array<{
          amount: string;
          unit: string;
        }>;
        WithdrawnForBuyer: Array<{
          amount: string;
          unit: string;
        }>;
        PaymentSource: {
          id: string;
          network: 'Preprod' | 'Mainnet';
          smartContractAddress: string;
          policyId: string | null;
          paymentType: 'Web3CardanoV1';
        };
        BuyerWallet: {
          id: string;
          walletVkey: string;
        } | null;
        SmartContractWallet: {
          id: string;
          walletVkey: string;
          walletAddress: string;
        } | null;
        metadata: string | null;
      }>;
    };
  };
};

export type GetPaymentResponse = GetPaymentResponses[keyof GetPaymentResponses];

export type PostPaymentData = {
  body?: {
    /**
     * The hash of the input data of the payment, should be sha256 hash of the input data, therefore needs to be in hex string format
     */
    inputHash: string;
    /**
     * The network the payment will be received on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The identifier of the agent that will be paid
     */
    agentIdentifier: string;
    /**
     * The amounts of the payment, should be null for fixed amount
     */
    RequestedFunds?: Array<{
      amount: string;
      unit: string;
    }>;
    /**
     * The type of payment contract used
     */
    paymentType: 'Web3CardanoV1';
    /**
     * The time after which the payment has to be submitted to the smart contract
     */
    payByTime?: Date;
    /**
     * The time after which the payment has to be submitted to the smart contract
     */
    submitResultTime?: Date;
    /**
     * The time after which the payment will be unlocked
     */
    unlockTime?: Date;
    /**
     * The time after which the payment will be unlocked for external dispute
     */
    externalDisputeUnlockTime?: Date;
    /**
     * Metadata to be stored with the payment request
     */
    metadata?: string;
    /**
     * The a unique nonce from the purchaser. Required to be in hex format
     */
    identifierFromPurchaser: string;
  };
  path?: never;
  query?: never;
  url: '/payment/';
};

export type PostPaymentErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type PostPaymentResponses = {
  /**
   * Payment request created
   */
  200: {
    data: {
      id: string;
      createdAt: string;
      updatedAt: string;
      blockchainIdentifier: string;
      payByTime: string;
      submitResultTime: string;
      unlockTime: string;
      externalDisputeUnlockTime: string;
      lastCheckedAt: string | null;
      requestedById: string;
      inputHash: string;
      resultHash: string;
      onChainState:
        | 'FundsLocked'
        | 'FundsOrDatumInvalid'
        | 'ResultSubmitted'
        | 'RefundRequested'
        | 'Disputed'
        | 'Withdrawn'
        | 'RefundWithdrawn'
        | 'DisputedWithdrawn';
      NextAction: {
        requestedAction:
          | 'None'
          | 'Ignore'
          | 'WaitingForManualAction'
          | 'WaitingForExternalAction'
          | 'SubmitResultRequested'
          | 'SubmitResultInitiated'
          | 'WithdrawRequested'
          | 'WithdrawInitiated'
          | 'AuthorizeRefundRequested'
          | 'AuthorizeRefundInitiated';
        resultHash: string | null;
        errorType: 'NetworkError' | 'Unknown';
        errorNote: string | null;
      };
      RequestedFunds: Array<{
        amount: string;
        unit: string;
      }>;
      WithdrawnForSeller: Array<{
        amount: string;
        unit: string;
      }>;
      WithdrawnForBuyer: Array<{
        amount: string;
        unit: string;
      }>;
      PaymentSource: {
        id: string;
        network: 'Preprod' | 'Mainnet';
        smartContractAddress: string;
        policyId: string | null;
        paymentType: 'Web3CardanoV1';
      };
      BuyerWallet: {
        id: string;
        walletVkey: string;
      } | null;
      SmartContractWallet: {
        id: string;
        walletVkey: string;
        walletAddress: string;
      } | null;
      metadata: string | null;
    };
    status: string;
  };
};

export type PostPaymentResponse =
  PostPaymentResponses[keyof PostPaymentResponses];

export type PostPaymentSubmitResultData = {
  body?: {
    /**
     * The network the payment was received on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The hash of the AI agent result to be submitted, should be sha256 hash of the result, therefore needs to be in hex string format
     */
    submitResultHash: string;
    /**
     * The identifier of the payment
     */
    blockchainIdentifier: string;
  };
  path?: never;
  query?: never;
  url: '/payment/submit-result';
};

export type PostPaymentSubmitResultErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type PostPaymentSubmitResultResponses = {
  /**
   * Payment updated
   */
  200: {
    data: {
      id: string;
      createdAt: string;
      updatedAt: string;
      blockchainIdentifier: string;
      payByTime: string | null;
      submitResultTime: string;
      unlockTime: string;
      externalDisputeUnlockTime: string;
      lastCheckedAt: string | null;
      requestedById: string;
      resultHash: string;
      inputHash: string;
      onChainState:
        | 'FundsLocked'
        | 'FundsOrDatumInvalid'
        | 'ResultSubmitted'
        | 'RefundRequested'
        | 'Disputed'
        | 'Withdrawn'
        | 'RefundWithdrawn'
        | 'DisputedWithdrawn';
      NextAction: {
        requestedAction:
          | 'None'
          | 'Ignore'
          | 'WaitingForManualAction'
          | 'WaitingForExternalAction'
          | 'SubmitResultRequested'
          | 'SubmitResultInitiated'
          | 'WithdrawRequested'
          | 'WithdrawInitiated'
          | 'AuthorizeRefundRequested'
          | 'AuthorizeRefundInitiated';
        errorType: 'NetworkError' | 'Unknown';
        errorNote: string | null;
        resultHash: string | null;
      };
      RequestedFunds: Array<{
        amount: string;
        unit: string;
      }>;
      WithdrawnForSeller: Array<{
        amount: string;
        unit: string;
      }>;
      WithdrawnForBuyer: Array<{
        amount: string;
        unit: string;
      }>;
      PaymentSource: {
        id: string;
        network: 'Preprod' | 'Mainnet';
        policyId: string | null;
        smartContractAddress: string;
        paymentType: 'Web3CardanoV1';
      };
      BuyerWallet: {
        id: string;
        walletVkey: string;
      } | null;
      SmartContractWallet: {
        id: string;
        walletVkey: string;
        walletAddress: string;
      } | null;
      metadata: string | null;
    };
    status: string;
  };
};

export type PostPaymentSubmitResultResponse =
  PostPaymentSubmitResultResponses[keyof PostPaymentSubmitResultResponses];

export type PostPaymentAuthorizeRefundData = {
  body?: {
    /**
     * The identifier of the purchase to be refunded
     */
    blockchainIdentifier: string;
    /**
     * The network the Cardano wallet will be used on
     */
    network: 'Preprod' | 'Mainnet';
  };
  path?: never;
  query?: never;
  url: '/payment/authorize-refund';
};

export type PostPaymentAuthorizeRefundErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type PostPaymentAuthorizeRefundResponses = {
  /**
   * API key deleted
   */
  200: {
    data: {
      id: string;
      createdAt: string;
      updatedAt: string;
      blockchainIdentifier: string;
      payByTime: string | null;
      submitResultTime: string;
      unlockTime: string;
      externalDisputeUnlockTime: string;
      lastCheckedAt: string | null;
      requestedById: string;
      resultHash: string;
      inputHash: string;
      onChainState:
        | 'FundsLocked'
        | 'FundsOrDatumInvalid'
        | 'ResultSubmitted'
        | 'RefundRequested'
        | 'Disputed'
        | 'Withdrawn'
        | 'RefundWithdrawn'
        | 'DisputedWithdrawn';
      NextAction: {
        requestedAction:
          | 'None'
          | 'Ignore'
          | 'WaitingForManualAction'
          | 'WaitingForExternalAction'
          | 'SubmitResultRequested'
          | 'SubmitResultInitiated'
          | 'WithdrawRequested'
          | 'WithdrawInitiated'
          | 'AuthorizeRefundRequested'
          | 'AuthorizeRefundInitiated';
        errorType: 'NetworkError' | 'Unknown';
        errorNote: string | null;
        resultHash: string | null;
      };
      RequestedFunds: Array<{
        amount: string;
        unit: string;
      }>;
      WithdrawnForSeller: Array<{
        amount: string;
        unit: string;
      }>;
      WithdrawnForBuyer: Array<{
        amount: string;
        unit: string;
      }>;
      PaymentSource: {
        id: string;
        network: 'Preprod' | 'Mainnet';
        smartContractAddress: string;
        policyId: string | null;
        paymentType: 'Web3CardanoV1';
      };
      BuyerWallet: {
        id: string;
        walletVkey: string;
      } | null;
      SmartContractWallet: {
        id: string;
        walletVkey: string;
        walletAddress: string;
      } | null;
      metadata: string | null;
    };
    status: string;
  };
};

export type PostPaymentAuthorizeRefundResponse =
  PostPaymentAuthorizeRefundResponses[keyof PostPaymentAuthorizeRefundResponses];

export type GetPurchaseData = {
  body?: never;
  path?: never;
  query: {
    /**
     * The number of purchases to return
     */
    limit?: number;
    /**
     * Used to paginate through the purchases. If this is provided, cursorId is required
     */
    cursorId?: string;
    /**
     * The network the purchases were made on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The smart contract address of the payment source
     */
    filterSmartContractAddress?: string | null;
    /**
     * Whether to include the full transaction and status history of the purchases
     */
    includeHistory?: string;
  };
  url: '/purchase/';
};

export type GetPurchaseErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type GetPurchaseResponses = {
  /**
   * Purchase status
   */
  200: {
    status: string;
    data: {
      Purchases: Array<{
        id: string;
        createdAt: string;
        updatedAt: string;
        blockchainIdentifier: string;
        lastCheckedAt: string | null;
        payByTime: string | null;
        submitResultTime: string;
        unlockTime: string;
        externalDisputeUnlockTime: string;
        requestedById: string;
        onChainState:
          | 'FundsLocked'
          | 'FundsOrDatumInvalid'
          | 'ResultSubmitted'
          | 'RefundRequested'
          | 'Disputed'
          | 'Withdrawn'
          | 'RefundWithdrawn'
          | 'DisputedWithdrawn';
        collateralReturnLovelace: string | null;
        cooldownTime: number;
        cooldownTimeOtherParty: number;
        inputHash: string;
        resultHash: string;
        NextAction: {
          inputHash: string;
          requestedAction:
            | 'None'
            | 'Ignore'
            | 'WaitingForManualAction'
            | 'WaitingForExternalAction'
            | 'FundsLockingRequested'
            | 'FundsLockingInitiated'
            | 'SetRefundRequestedRequested'
            | 'SetRefundRequestedInitiated'
            | 'UnSetRefundRequestedRequested'
            | 'UnSetRefundRequestedInitiated'
            | 'WithdrawRefundRequested'
            | 'WithdrawRefundInitiated';
          errorType: 'NetworkError' | 'InsufficientFunds' | 'Unknown';
          errorNote: string | null;
        };
        CurrentTransaction: {
          id: string;
          createdAt: string;
          updatedAt: string;
          txHash: string;
          status: 'Pending' | 'Confirmed' | 'FailedViaTimeout' | 'RolledBack';
        } | null;
        TransactionHistory: Array<{
          id: string;
          createdAt: string;
          updatedAt: string;
          txHash: string;
          status: 'Pending' | 'Confirmed' | 'FailedViaTimeout' | 'RolledBack';
        }>;
        PaidFunds: Array<{
          amount: string;
          unit: string;
        }>;
        WithdrawnForSeller: Array<{
          amount: string;
          unit: string;
        }>;
        WithdrawnForBuyer: Array<{
          amount: string;
          unit: string;
        }>;
        PaymentSource: {
          id: string;
          network: 'Preprod' | 'Mainnet';
          smartContractAddress: string;
          policyId: string | null;
          paymentType: 'Web3CardanoV1';
        };
        SellerWallet: {
          id: string;
          walletVkey: string;
        } | null;
        SmartContractWallet: {
          id: string;
          walletVkey: string;
          walletAddress: string;
        } | null;
        metadata: string | null;
      }>;
    };
  };
};

export type GetPurchaseResponse =
  GetPurchaseResponses[keyof GetPurchaseResponses];

export type PostPurchaseData = {
  body?: {
    /**
     * The identifier of the purchase. Is provided by the seller
     */
    blockchainIdentifier: string;
    /**
     * The network the transaction will be made on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The hash of the input data of the purchase, should be sha256 hash of the input data, therefore needs to be in hex string format
     */
    inputHash: string;
    /**
     * The verification key of the seller
     */
    sellerVkey: string;
    /**
     * The identifier of the agent that is being purchased
     */
    agentIdentifier: string;
    /**
     * The amounts to be paid for the purchase
     */
    Amounts?: Array<{
      amount: string;
      unit: string;
    }>;
    /**
     * The payment type of smart contract used
     */
    paymentType: 'Web3CardanoV1';
    /**
     * The time after which the purchase will be unlocked. In unix time (number)
     */
    unlockTime: string;
    /**
     * The time after which the purchase will be unlocked for external dispute. In unix time (number)
     */
    externalDisputeUnlockTime: string;
    /**
     * The time by which the result has to be submitted. In unix time (number)
     */
    submitResultTime: string;
    /**
     * The time after which the purchase has to be submitted to the smart contract
     */
    payByTime: string;
    /**
     * Metadata to be stored with the purchase request
     */
    metadata?: string;
    /**
     * The nonce of the purchaser of the purchase, needs to be in hex format
     */
    identifierFromPurchaser: string;
  };
  path?: never;
  query?: never;
  url: '/purchase/';
};

export type PostPurchaseErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Conflict (purchase request already exists)
   */
  409: {
    status: string;
    error: {
      message: string;
    };
    id: string;
    object: {
      id: string;
      createdAt: string;
      updatedAt: string;
      blockchainIdentifier: string;
      lastCheckedAt: string | null;
      payByTime: string | null;
      submitResultTime: string;
      unlockTime: string;
      externalDisputeUnlockTime: string;
      requestedById: string;
      resultHash: string;
      inputHash: string;
      onChainState:
        | 'FundsLocked'
        | 'FundsOrDatumInvalid'
        | 'ResultSubmitted'
        | 'RefundRequested'
        | 'Disputed'
        | 'Withdrawn'
        | 'RefundWithdrawn'
        | 'DisputedWithdrawn';
      NextAction: {
        requestedAction:
          | 'None'
          | 'Ignore'
          | 'WaitingForManualAction'
          | 'WaitingForExternalAction'
          | 'FundsLockingRequested'
          | 'FundsLockingInitiated'
          | 'SetRefundRequestedRequested'
          | 'SetRefundRequestedInitiated'
          | 'UnSetRefundRequestedRequested'
          | 'UnSetRefundRequestedInitiated'
          | 'WithdrawRefundRequested'
          | 'WithdrawRefundInitiated';
        errorType: 'NetworkError' | 'InsufficientFunds' | 'Unknown';
        errorNote: string | null;
      };
      CurrentTransaction: {
        id: string;
        createdAt: string;
        updatedAt: string;
        txHash: string;
        status: 'Pending' | 'Confirmed' | 'FailedViaTimeout' | 'RolledBack';
      } | null;
      PaidFunds: Array<{
        amount: string;
        unit: string;
      }>;
      WithdrawnForSeller: Array<{
        amount: string;
        unit: string;
      }>;
      WithdrawnForBuyer: Array<{
        amount: string;
        unit: string;
      }>;
      PaymentSource: {
        id: string;
        network: 'Preprod' | 'Mainnet';
        policyId: string | null;
        smartContractAddress: string;
        paymentType: 'Web3CardanoV1';
      };
      SellerWallet: {
        id: string;
        walletVkey: string;
      } | null;
      SmartContractWallet: {
        id: string;
        walletVkey: string;
        walletAddress: string;
      } | null;
      metadata: string | null;
    };
  };
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type PostPurchaseError = PostPurchaseErrors[keyof PostPurchaseErrors];

export type PostPurchaseResponses = {
  /**
   * Purchase request created
   */
  200: {
    data: {
      id: string;
      createdAt: string;
      updatedAt: string;
      blockchainIdentifier: string;
      lastCheckedAt: string | null;
      payByTime: string | null;
      submitResultTime: string;
      unlockTime: string;
      externalDisputeUnlockTime: string;
      requestedById: string;
      resultHash: string;
      inputHash: string;
      onChainState:
        | 'FundsLocked'
        | 'FundsOrDatumInvalid'
        | 'ResultSubmitted'
        | 'RefundRequested'
        | 'Disputed'
        | 'Withdrawn'
        | 'RefundWithdrawn'
        | 'DisputedWithdrawn';
      NextAction: {
        requestedAction:
          | 'None'
          | 'Ignore'
          | 'WaitingForManualAction'
          | 'WaitingForExternalAction'
          | 'FundsLockingRequested'
          | 'FundsLockingInitiated'
          | 'SetRefundRequestedRequested'
          | 'SetRefundRequestedInitiated'
          | 'UnSetRefundRequestedRequested'
          | 'UnSetRefundRequestedInitiated'
          | 'WithdrawRefundRequested'
          | 'WithdrawRefundInitiated';
        errorType: 'NetworkError' | 'InsufficientFunds' | 'Unknown';
        errorNote: string | null;
      };
      CurrentTransaction: {
        id: string;
        createdAt: string;
        updatedAt: string;
        txHash: string;
        status: 'Pending' | 'Confirmed' | 'FailedViaTimeout' | 'RolledBack';
      } | null;
      PaidFunds: Array<{
        amount: string;
        unit: string;
      }>;
      WithdrawnForSeller: Array<{
        amount: string;
        unit: string;
      }>;
      WithdrawnForBuyer: Array<{
        amount: string;
        unit: string;
      }>;
      PaymentSource: {
        id: string;
        network: 'Preprod' | 'Mainnet';
        policyId: string | null;
        smartContractAddress: string;
        paymentType: 'Web3CardanoV1';
      };
      SellerWallet: {
        id: string;
        walletVkey: string;
      } | null;
      SmartContractWallet: {
        id: string;
        walletVkey: string;
        walletAddress: string;
      } | null;
      metadata: string | null;
    };
    status: string;
  };
};

export type PostPurchaseResponse =
  PostPurchaseResponses[keyof PostPurchaseResponses];

export type PostPurchaseRequestRefundData = {
  body?: {
    /**
     * The identifier of the purchase to be refunded
     */
    blockchainIdentifier: string;
    /**
     * The network the Cardano wallet will be used on
     */
    network: 'Preprod' | 'Mainnet';
  };
  path?: never;
  query?: never;
  url: '/purchase/request-refund';
};

export type PostPurchaseRequestRefundErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type PostPurchaseRequestRefundResponses = {
  /**
   * API key deleted
   */
  200: {
    data: {
      id: string;
      createdAt: string;
      updatedAt: string;
      blockchainIdentifier: string;
      lastCheckedAt: string | null;
      payByTime: string | null;
      submitResultTime: string;
      unlockTime: string;
      externalDisputeUnlockTime: string;
      requestedById: string;
      resultHash: string;
      onChainState:
        | 'FundsLocked'
        | 'FundsOrDatumInvalid'
        | 'ResultSubmitted'
        | 'RefundRequested'
        | 'Disputed'
        | 'Withdrawn'
        | 'RefundWithdrawn'
        | 'DisputedWithdrawn';
      NextAction: {
        requestedAction:
          | 'None'
          | 'Ignore'
          | 'WaitingForManualAction'
          | 'WaitingForExternalAction'
          | 'FundsLockingRequested'
          | 'FundsLockingInitiated'
          | 'SetRefundRequestedRequested'
          | 'SetRefundRequestedInitiated'
          | 'UnSetRefundRequestedRequested'
          | 'UnSetRefundRequestedInitiated'
          | 'WithdrawRefundRequested'
          | 'WithdrawRefundInitiated';
        errorType: 'NetworkError' | 'InsufficientFunds' | 'Unknown';
        errorNote: string | null;
      };
      CurrentTransaction: {
        id: string;
        createdAt: string;
        updatedAt: string;
        txHash: string;
        status: 'Pending' | 'Confirmed' | 'FailedViaTimeout' | 'RolledBack';
      } | null;
      PaidFunds: Array<{
        amount: string;
        unit: string;
      }>;
      WithdrawnForSeller: Array<{
        amount: string;
        unit: string;
      }>;
      WithdrawnForBuyer: Array<{
        amount: string;
        unit: string;
      }>;
      PaymentSource: {
        id: string;
        network: 'Preprod' | 'Mainnet';
        policyId: string | null;
        smartContractAddress: string;
        paymentType: 'Web3CardanoV1';
      };
      SellerWallet: {
        id: string;
        walletVkey: string;
      } | null;
      SmartContractWallet: {
        id: string;
        walletVkey: string;
        walletAddress: string;
      } | null;
      metadata: string | null;
    };
    status: string;
  };
};

export type PostPurchaseRequestRefundResponse =
  PostPurchaseRequestRefundResponses[keyof PostPurchaseRequestRefundResponses];

export type PostPurchaseCancelRefundRequestData = {
  body?: {
    /**
     * The identifier of the purchase to be refunded
     */
    blockchainIdentifier: string;
    /**
     * The network the Cardano wallet will be used on
     */
    network: 'Preprod' | 'Mainnet';
  };
  path?: never;
  query?: never;
  url: '/purchase/cancel-refund-request';
};

export type PostPurchaseCancelRefundRequestErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type PostPurchaseCancelRefundRequestResponses = {
  /**
   * API key deleted
   */
  200: {
    data: {
      id: string;
      createdAt: string;
      updatedAt: string;
      blockchainIdentifier: string;
      lastCheckedAt: string | null;
      payByTime: string | null;
      submitResultTime: string;
      unlockTime: string;
      externalDisputeUnlockTime: string;
      requestedById: string;
      resultHash: string;
      onChainState:
        | 'FundsLocked'
        | 'FundsOrDatumInvalid'
        | 'ResultSubmitted'
        | 'RefundRequested'
        | 'Disputed'
        | 'Withdrawn'
        | 'RefundWithdrawn'
        | 'DisputedWithdrawn';
      NextAction: {
        requestedAction:
          | 'None'
          | 'Ignore'
          | 'WaitingForManualAction'
          | 'WaitingForExternalAction'
          | 'FundsLockingRequested'
          | 'FundsLockingInitiated'
          | 'SetRefundRequestedRequested'
          | 'SetRefundRequestedInitiated'
          | 'UnSetRefundRequestedRequested'
          | 'UnSetRefundRequestedInitiated'
          | 'WithdrawRefundRequested'
          | 'WithdrawRefundInitiated';
        errorType: 'NetworkError' | 'InsufficientFunds' | 'Unknown';
        errorNote: string | null;
      };
      CurrentTransaction: {
        id: string;
        createdAt: string;
        updatedAt: string;
        txHash: string;
        status: 'Pending' | 'Confirmed' | 'FailedViaTimeout' | 'RolledBack';
      } | null;
      PaidFunds: Array<{
        amount: string;
        unit: string;
      }>;
      WithdrawnForSeller: Array<{
        amount: string;
        unit: string;
      }>;
      WithdrawnForBuyer: Array<{
        amount: string;
        unit: string;
      }>;
      PaymentSource: {
        id: string;
        network: 'Preprod' | 'Mainnet';
        policyId: string | null;
        smartContractAddress: string;
        paymentType: 'Web3CardanoV1';
      };
      SellerWallet: {
        id: string;
        walletVkey: string;
      } | null;
      SmartContractWallet: {
        id: string;
        walletVkey: string;
        walletAddress: string;
      } | null;
      metadata: string | null;
    };
    status: string;
  };
};

export type PostPurchaseCancelRefundRequestResponse =
  PostPurchaseCancelRefundRequestResponses[keyof PostPurchaseCancelRefundRequestResponses];

export type PostPaymentResolveBlockchainIdentifierData = {
  body?: {
    /**
     * The blockchain identifier to resolve
     */
    blockchainIdentifier: string;
    /**
     * The network the purchases were made on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The smart contract address of the payment source
     */
    filterSmartContractAddress?: string | null;
    /**
     * Whether to include the full transaction and status history of the purchases
     */
    includeHistory?: string;
  };
  path?: never;
  query?: never;
  url: '/payment/resolve-blockchain-identifier';
};

export type PostPaymentResolveBlockchainIdentifierErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Payment request not found
   */
  404: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type PostPaymentResolveBlockchainIdentifierResponses = {
  /**
   * Payment request resolved
   */
  200: {
    status: string;
    data: {
      id: string;
      createdAt: string;
      updatedAt: string;
      blockchainIdentifier: string;
      lastCheckedAt: string | null;
      payByTime: string | null;
      submitResultTime: string;
      unlockTime: string;
      collateralReturnLovelace: string | null;
      externalDisputeUnlockTime: string;
      requestedById: string;
      resultHash: string;
      inputHash: string;
      cooldownTime: number;
      cooldownTimeOtherParty: number;
      onChainState:
        | 'FundsLocked'
        | 'FundsOrDatumInvalid'
        | 'ResultSubmitted'
        | 'RefundRequested'
        | 'Disputed'
        | 'Withdrawn'
        | 'RefundWithdrawn'
        | 'DisputedWithdrawn';
      NextAction: {
        requestedAction:
          | 'None'
          | 'Ignore'
          | 'WaitingForManualAction'
          | 'WaitingForExternalAction'
          | 'SubmitResultRequested'
          | 'SubmitResultInitiated'
          | 'WithdrawRequested'
          | 'WithdrawInitiated'
          | 'AuthorizeRefundRequested'
          | 'AuthorizeRefundInitiated';
        errorType: 'NetworkError' | 'Unknown';
        errorNote: string | null;
        resultHash: string | null;
      };
      CurrentTransaction: {
        id: string;
        createdAt: string;
        updatedAt: string;
        txHash: string | null;
      } | null;
      TransactionHistory: Array<{
        id: string;
        createdAt: string;
        updatedAt: string;
        txHash: string | null;
      }> | null;
      RequestedFunds: Array<{
        amount: string;
        unit: string;
      }>;
      WithdrawnForSeller: Array<{
        amount: string;
        unit: string;
      }>;
      WithdrawnForBuyer: Array<{
        amount: string;
        unit: string;
      }>;
      PaymentSource: {
        id: string;
        network: 'Preprod' | 'Mainnet';
        smartContractAddress: string;
        policyId: string | null;
        paymentType: 'Web3CardanoV1';
      };
      BuyerWallet: {
        id: string;
        walletVkey: string;
      } | null;
      SmartContractWallet: {
        id: string;
        walletVkey: string;
        walletAddress: string;
      } | null;
      metadata: string | null;
    };
  };
};

export type PostPaymentResolveBlockchainIdentifierResponse =
  PostPaymentResolveBlockchainIdentifierResponses[keyof PostPaymentResolveBlockchainIdentifierResponses];

export type PostPurchaseResolveBlockchainIdentifierData = {
  body?: {
    /**
     * The blockchain identifier to resolve
     */
    blockchainIdentifier: string;
    /**
     * The network the purchases were made on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The smart contract address of the payment source
     */
    filterSmartContractAddress?: string | null;
    /**
     * Whether to include the full transaction and status history of the purchases
     */
    includeHistory?: string;
  };
  path?: never;
  query?: never;
  url: '/purchase/resolve-blockchain-identifier';
};

export type PostPurchaseResolveBlockchainIdentifierErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Purchase request not found
   */
  404: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type PostPurchaseResolveBlockchainIdentifierResponses = {
  /**
   * Purchase request resolved
   */
  200: {
    status: string;
    data: {
      id: string;
      createdAt: string;
      updatedAt: string;
      blockchainIdentifier: string;
      lastCheckedAt: string | null;
      payByTime: string | null;
      submitResultTime: string;
      unlockTime: string;
      externalDisputeUnlockTime: string;
      requestedById: string;
      onChainState:
        | 'FundsLocked'
        | 'FundsOrDatumInvalid'
        | 'ResultSubmitted'
        | 'RefundRequested'
        | 'Disputed'
        | 'Withdrawn'
        | 'RefundWithdrawn'
        | 'DisputedWithdrawn';
      collateralReturnLovelace: string | null;
      cooldownTime: number;
      cooldownTimeOtherParty: number;
      inputHash: string;
      resultHash: string;
      NextAction: {
        inputHash: string;
        requestedAction:
          | 'None'
          | 'Ignore'
          | 'WaitingForManualAction'
          | 'WaitingForExternalAction'
          | 'FundsLockingRequested'
          | 'FundsLockingInitiated'
          | 'SetRefundRequestedRequested'
          | 'SetRefundRequestedInitiated'
          | 'UnSetRefundRequestedRequested'
          | 'UnSetRefundRequestedInitiated'
          | 'WithdrawRefundRequested'
          | 'WithdrawRefundInitiated';
        errorType: 'NetworkError' | 'InsufficientFunds' | 'Unknown';
        errorNote: string | null;
      };
      CurrentTransaction: {
        id: string;
        createdAt: string;
        updatedAt: string;
        txHash: string;
        status: 'Pending' | 'Confirmed' | 'FailedViaTimeout' | 'RolledBack';
      } | null;
      TransactionHistory: Array<{
        id: string;
        createdAt: string;
        updatedAt: string;
        txHash: string;
        status: 'Pending' | 'Confirmed' | 'FailedViaTimeout' | 'RolledBack';
      }>;
      PaidFunds: Array<{
        amount: string;
        unit: string;
      }>;
      WithdrawnForSeller: Array<{
        amount: string;
        unit: string;
      }>;
      WithdrawnForBuyer: Array<{
        amount: string;
        unit: string;
      }>;
      PaymentSource: {
        id: string;
        network: 'Preprod' | 'Mainnet';
        smartContractAddress: string;
        policyId: string | null;
        paymentType: 'Web3CardanoV1';
      };
      SellerWallet: {
        id: string;
        walletVkey: string;
      } | null;
      SmartContractWallet: {
        id: string;
        walletVkey: string;
        walletAddress: string;
      } | null;
      metadata: string | null;
    };
  };
};

export type PostPurchaseResolveBlockchainIdentifierResponse =
  PostPurchaseResolveBlockchainIdentifierResponses[keyof PostPurchaseResolveBlockchainIdentifierResponses];

export type GetRegistryWalletData = {
  body?: never;
  path?: never;
  query: {
    /**
     * The payment key of the wallet to be queried
     */
    walletVKey: string;
    /**
     * The Cardano network used to register the agent on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The smart contract address of the payment source to which the registration belongs
     */
    smartContractAddress?: string;
  };
  url: '/registry/wallet';
};

export type GetRegistryWalletResponses = {
  /**
   * Agent metadata
   */
  200: {
    status: string;
    data: {
      Assets: Array<{
        policyId: string;
        assetName: string;
        agentIdentifier: string;
        Metadata: {
          name: string;
          description?: string | null;
          apiBaseUrl: string;
          ExampleOutputs: Array<{
            name: string;
            mimeType: string;
            url: string;
          }>;
          Tags: Array<string>;
          Capability?: {
            name?: string | null;
            version?: string | null;
          } | null;
          Author: {
            name: string;
            contactEmail?: string | null;
            contactOther?: string | null;
            organization?: string | null;
          };
          Legal?: {
            privacyPolicy?: string | null;
            terms?: string | null;
            other?: string | null;
          } | null;
          AgentPricing: {
            pricingType: 'Fixed';
            Pricing: Array<{
              amount: string;
              unit: string;
            }>;
          };
          image: string;
          metadataVersion: number;
        };
      }>;
    };
  };
};

export type GetRegistryWalletResponse =
  GetRegistryWalletResponses[keyof GetRegistryWalletResponses];

export type DeleteRegistryData = {
  body?: {
    /**
     * The database ID of the agent registration record to be deleted.
     */
    id: string;
  };
  path?: never;
  query?: never;
  url: '/registry/';
};

export type DeleteRegistryErrors = {
  /**
   * Bad Request - Invalid state for deletion
   */
  400: {
    status: string;
    error: {
      message: string;
    };
  };
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Agent Registration not found
   */
  404: {
    status: string;
    error: {
      message: string;
    };
  };
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type DeleteRegistryError =
  DeleteRegistryErrors[keyof DeleteRegistryErrors];

export type DeleteRegistryResponses = {
  /**
   * Agent registration deleted successfully
   */
  200: {
    status: string;
    data: {
      id: string;
    };
  };
};

export type DeleteRegistryResponse =
  DeleteRegistryResponses[keyof DeleteRegistryResponses];

export type GetRegistryData = {
  body?: never;
  path?: never;
  query: {
    /**
     * The cursor id to paginate through the results
     */
    cursorId?: string;
    /**
     * The Cardano network used to register the agent on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The smart contract address of the payment source
     */
    filterSmartContractAddress?: string | null;
  };
  url: '/registry/';
};

export type GetRegistryResponses = {
  /**
   * Agent metadata
   */
  200: {
    status: string;
    data: {
      Assets: Array<{
        error: string | null;
        id: string;
        name: string;
        description: string | null;
        apiBaseUrl: string;
        Capability: {
          name: string | null;
          version: string | null;
        };
        Author: {
          name: string;
          contactEmail: string | null;
          contactOther: string | null;
          organization: string | null;
        };
        Legal: {
          privacyPolicy: string | null;
          terms: string | null;
          other: string | null;
        };
        state:
          | 'RegistrationRequested'
          | 'RegistrationInitiated'
          | 'RegistrationConfirmed'
          | 'RegistrationFailed'
          | 'DeregistrationRequested'
          | 'DeregistrationInitiated'
          | 'DeregistrationConfirmed'
          | 'DeregistrationFailed';
        Tags: Array<string>;
        createdAt: string;
        updatedAt: string;
        lastCheckedAt: string | null;
        ExampleOutputs: Array<{
          name: string;
          url: string;
          mimeType: string;
        }>;
        agentIdentifier: string | null;
        AgentPricing: {
          pricingType: 'Fixed';
          Pricing: Array<{
            amount: string;
            unit: string;
          }>;
        };
        SmartContractWallet: {
          walletVkey: string;
          walletAddress: string;
        };
        CurrentTransaction: {
          txHash: string;
          status: 'Pending' | 'Confirmed' | 'FailedViaTimeout' | 'RolledBack';
        } | null;
      }>;
    };
  };
};

export type GetRegistryResponse =
  GetRegistryResponses[keyof GetRegistryResponses];

export type PostRegistryData = {
  body?: {
    /**
     * The Cardano network used to register the agent on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The payment key of a specific wallet used for the registration
     */
    sellingWalletVkey: string;
    ExampleOutputs: Array<{
      name: string;
      url: string;
      mimeType: string;
    }>;
    /**
     * Tags used in the registry metadata
     */
    Tags: Array<string>;
    /**
     * Name of the agent
     */
    name: string;
    /**
     * Base URL of the agent, to request interactions
     */
    apiBaseUrl: string;
    /**
     * Description of the agent
     */
    description: string;
    /**
     * Provide information about the used AI model and version
     */
    Capability: {
      name: string;
      version: string;
    };
    AgentPricing: {
      pricingType: 'Fixed';
      /**
       * Price for a default interaction
       */
      Pricing: Array<{
        unit: string;
        amount: string;
      }>;
    };
    /**
     * Legal information about the agent
     */
    Legal?: {
      privacyPolicy?: string;
      terms?: string;
      other?: string;
    };
    /**
     * Author information about the agent
     */
    Author: {
      name: string;
      contactEmail?: string;
      contactOther?: string;
      organization?: string;
    };
  };
  path?: never;
  query?: never;
  url: '/registry/';
};

export type PostRegistryResponses = {
  /**
   * Agent registered
   */
  200: {
    status: string;
    data: {
      id: string;
      name: string;
      apiBaseUrl: string;
      Capability: {
        name: string | null;
        version: string | null;
      };
      Legal: {
        privacyPolicy: string | null;
        terms: string | null;
        other: string | null;
      };
      Author: {
        name: string;
        contactEmail: string | null;
        contactOther: string | null;
        organization: string | null;
      };
      description: string | null;
      Tags: Array<string>;
      state:
        | 'RegistrationRequested'
        | 'RegistrationInitiated'
        | 'RegistrationConfirmed'
        | 'RegistrationFailed'
        | 'DeregistrationRequested'
        | 'DeregistrationInitiated'
        | 'DeregistrationConfirmed'
        | 'DeregistrationFailed';
      SmartContractWallet: {
        walletVkey: string;
        walletAddress: string;
      };
      ExampleOutputs: Array<{
        name: string;
        url: string;
        mimeType: string;
      }>;
      AgentPricing: {
        pricingType: 'Fixed';
        Pricing: Array<{
          unit: string;
          amount: string;
        }>;
      };
    };
  };
};

export type PostRegistryResponse =
  PostRegistryResponses[keyof PostRegistryResponses];

export type PostRegistryDeregisterData = {
  body?: {
    /**
     * The identifier of the registration (asset) to be deregistered
     */
    agentIdentifier: string;
    /**
     * The network the registration was made on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The smart contract address of the payment contract to which the registration belongs
     */
    smartContractAddress?: string;
  };
  path?: never;
  query?: never;
  url: '/registry/deregister';
};

export type PostRegistryDeregisterResponses = {
  /**
   * Payment source deleted
   */
  200: {
    status: string;
    data: {
      id: string;
      name: string;
      apiBaseUrl: string;
      Capability: {
        name: string | null;
        version: string | null;
      };
      Author: {
        name: string;
        contactEmail: string | null;
        contactOther: string | null;
        organization: string | null;
      };
      Legal: {
        privacyPolicy: string | null;
        terms: string | null;
        other: string | null;
      };
      description: string | null;
      Tags: Array<string>;
      SmartContractWallet: {
        walletVkey: string;
        walletAddress: string;
      };
      state:
        | 'RegistrationRequested'
        | 'RegistrationInitiated'
        | 'RegistrationConfirmed'
        | 'RegistrationFailed'
        | 'DeregistrationRequested'
        | 'DeregistrationInitiated'
        | 'DeregistrationConfirmed'
        | 'DeregistrationFailed';
      ExampleOutputs: Array<{
        name: string;
        url: string;
        mimeType: string;
      }>;
      AgentPricing: {
        pricingType: 'Fixed';
        Pricing: Array<{
          unit: string;
          amount: string;
        }>;
      };
    };
  };
};

export type PostRegistryDeregisterResponse =
  PostRegistryDeregisterResponses[keyof PostRegistryDeregisterResponses];

export type GetPaymentSourceData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * The number of payment sources to return
     */
    take?: number;
    /**
     * Used to paginate through the payment sources
     */
    cursorId?: string;
  };
  url: '/payment-source/';
};

export type GetPaymentSourceResponses = {
  /**
   * Payment source status
   */
  200: {
    status: string;
    data: {
      PaymentSources: Array<{
        id: string;
        createdAt: string;
        updatedAt: string;
        network: 'Preprod' | 'Mainnet';
        policyId: string | null;
        smartContractAddress: string;
        paymentType: 'Web3CardanoV1';
        lastIdentifierChecked: string | null;
        lastCheckedAt: string | null;
        AdminWallets: Array<{
          walletAddress: string;
          order: number;
        }>;
        PurchasingWallets: Array<{
          id: string;
          walletVkey: string;
          walletAddress: string;
          collectionAddress: string | null;
          note: string | null;
        }>;
        SellingWallets: Array<{
          id: string;
          walletVkey: string;
          walletAddress: string;
          collectionAddress: string | null;
          note: string | null;
        }>;
        FeeReceiverNetworkWallet: {
          walletAddress: string;
        };
        feeRatePermille: number;
      }>;
    };
  };
};

export type GetPaymentSourceResponse =
  GetPaymentSourceResponses[keyof GetPaymentSourceResponses];

export type DeletePaymentSourceExtendedData = {
  body?: {
    /**
     * The id of the payment source to be deleted
     */
    id: string;
  };
  path?: never;
  query?: never;
  url: '/payment-source-extended/';
};

export type DeletePaymentSourceExtendedResponses = {
  /**
   * Payment source deleted
   */
  200: {
    status: string;
    data: {
      id: string;
    };
  };
};

export type DeletePaymentSourceExtendedResponse =
  DeletePaymentSourceExtendedResponses[keyof DeletePaymentSourceExtendedResponses];

export type GetPaymentSourceExtendedData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * The number of payment sources to return
     */
    take?: number;
    /**
     * Used to paginate through the payment sources
     */
    cursorId?: string;
  };
  url: '/payment-source-extended/';
};

export type GetPaymentSourceExtendedResponses = {
  /**
   * Payment source status
   */
  200: {
    status: string;
    data: {
      ExtendedPaymentSources: Array<{
        id: string;
        createdAt: string;
        updatedAt: string;
        network: 'Preprod' | 'Mainnet';
        policyId: string | null;
        smartContractAddress: string;
        paymentType: 'Web3CardanoV1';
        PaymentSourceConfig: {
          rpcProviderApiKey: string;
          rpcProvider: 'Blockfrost';
        };
        lastIdentifierChecked: string | null;
        syncInProgress: boolean;
        lastCheckedAt: string | null;
        AdminWallets: Array<{
          walletAddress: string;
          order: number;
        }>;
        PurchasingWallets: Array<{
          id: string;
          walletVkey: string;
          walletAddress: string;
          collectionAddress: string | null;
          note: string | null;
        }>;
        SellingWallets: Array<{
          id: string;
          walletVkey: string;
          walletAddress: string;
          collectionAddress: string | null;
          note: string | null;
        }>;
        FeeReceiverNetworkWallet: {
          walletAddress: string;
        };
        feeRatePermille: number;
      }>;
    };
  };
};

export type GetPaymentSourceExtendedResponse =
  GetPaymentSourceExtendedResponses[keyof GetPaymentSourceExtendedResponses];

export type PatchPaymentSourceExtendedData = {
  body?: {
    /**
     * The id of the payment source to be updated
     */
    id: string;
    PaymentSourceConfig?: {
      /**
       * The rpc provider (blockfrost) api key to be used for the payment source
       */
      rpcProviderApiKey: string;
      /**
       * The rpc provider to be used for the payment contract
       */
      rpcProvider: 'Blockfrost';
    };
    /**
     * The mnemonic of the purchasing wallets to be added
     */
    AddPurchasingWallets?: Array<{
      walletMnemonic: string;
      note: string;
      /**
       * The collection address of the purchasing wallet
       */
      collectionAddress: string | null;
    }>;
    /**
     * The mnemonic of the selling wallets to be added
     */
    AddSellingWallets?: Array<{
      walletMnemonic: string;
      note: string;
      /**
       * The collection address of the selling wallet
       */
      collectionAddress: string | null;
    }>;
    /**
     * The ids of the purchasing wallets to be removed. Please backup the mnemonic of the old wallet before removing it.
     */
    RemovePurchasingWallets?: Array<{
      id: string;
    }>;
    /**
     * The ids of the selling wallets to be removed. Please backup the mnemonic of the old wallet before removing it.
     */
    RemoveSellingWallets?: Array<{
      id: string;
    }>;
    /**
     * The latest identifier of the payment source. Usually should not be changed
     */
    lastIdentifierChecked?: string | null;
  };
  path?: never;
  query?: never;
  url: '/payment-source-extended/';
};

export type PatchPaymentSourceExtendedResponses = {
  /**
   * Payment contract updated
   */
  200: {
    status: string;
    data: {
      id: string;
      createdAt: string;
      updatedAt: string;
      network: 'Preprod' | 'Mainnet';
      smartContractAddress: string;
      paymentType: 'Web3CardanoV1';
      PaymentSourceConfig: {
        rpcProviderApiKey: string;
        rpcProvider: 'Blockfrost';
      };
      lastIdentifierChecked: string | null;
      syncInProgress: boolean;
      lastCheckedAt: string | null;
      AdminWallets: Array<{
        walletAddress: string;
        order: number;
      }>;
      PurchasingWallets: Array<{
        id: string;
        walletVkey: string;
        walletAddress: string;
        collectionAddress: string | null;
        note: string | null;
      }>;
      SellingWallets: Array<{
        id: string;
        walletVkey: string;
        walletAddress: string;
        collectionAddress: string | null;
        note: string | null;
      }>;
      FeeReceiverNetworkWallet: {
        walletAddress: string;
      };
      feeRatePermille: number;
    };
  };
};

export type PatchPaymentSourceExtendedResponse =
  PatchPaymentSourceExtendedResponses[keyof PatchPaymentSourceExtendedResponses];

export type PostPaymentSourceExtendedData = {
  body?: {
    /**
     * The network the payment source will be used on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The type of payment source used
     */
    paymentType: 'Web3CardanoV1';
    PaymentSourceConfig: {
      /**
       * The rpc provider (blockfrost) api key to be used for the payment source
       */
      rpcProviderApiKey: string;
      /**
       * The rpc provider to be used for the payment source
       */
      rpcProvider: 'Blockfrost';
    };
    /**
     * The fee in permille to be used for the payment source. The default contract uses 50 (5%)
     */
    feeRatePermille: number | null;
    /**
     * The cooldown time in milliseconds to be used for the payment source. The default contract uses 1000 * 60 * 7 (7 minutes)
     */
    cooldownTime?: number | null;
    /**
     * The wallet addresses of the admin wallets (exactly 3)
     */
    AdminWallets: [
      {
        walletAddress: string;
      },
      {
        walletAddress: string;
      },
      {
        walletAddress: string;
      },
    ];
    /**
     * The wallet address of the network fee receiver wallet
     */
    FeeReceiverNetworkWallet: {
      walletAddress: string;
    };
    /**
     * The mnemonic of the purchasing wallets to be added. Please backup the mnemonic of the wallets.
     */
    PurchasingWallets: Array<{
      walletMnemonic: string;
      /**
       * The collection address of the purchasing wallet
       */
      collectionAddress: string | null;
      note: string;
    }>;
    /**
     * The mnemonic of the selling wallets to be added. Please backup the mnemonic of the wallets.
     */
    SellingWallets: Array<{
      walletMnemonic: string;
      /**
       * The collection address of the selling wallet
       */
      collectionAddress: string | null;
      note: string;
    }>;
  };
  path?: never;
  query?: never;
  url: '/payment-source-extended/';
};

export type PostPaymentSourceExtendedResponses = {
  /**
   * Payment source created
   */
  200: {
    status: string;
    data: {
      id: string;
      createdAt: string;
      updatedAt: string;
      network: 'Preprod' | 'Mainnet';
      smartContractAddress: string;
      paymentType: 'Web3CardanoV1';
      PaymentSourceConfig: {
        rpcProviderApiKey: string;
        rpcProvider: 'Blockfrost';
      };
      lastIdentifierChecked: string | null;
      syncInProgress: boolean;
      lastCheckedAt: string | null;
      AdminWallets: Array<{
        walletAddress: string;
        order: number;
      }>;
      PurchasingWallets: Array<{
        id: string;
        walletVkey: string;
        walletAddress: string;
        collectionAddress: string | null;
        note: string | null;
      }>;
      SellingWallets: Array<{
        id: string;
        walletVkey: string;
        walletAddress: string;
        collectionAddress: string | null;
        note: string | null;
      }>;
      FeeReceiverNetworkWallet: {
        walletAddress: string;
      };
      feeRatePermille: number;
    };
  };
};

export type PostPaymentSourceExtendedResponse =
  PostPaymentSourceExtendedResponses[keyof PostPaymentSourceExtendedResponses];

export type GetUtxosData = {
  body?: never;
  path?: never;
  query: {
    /**
     * The address to get the UTXOs for
     */
    address: string;
    network: 'Preprod' | 'Mainnet';
    /**
     * The number of UTXOs to get
     */
    count?: number;
    /**
     * The page number to get
     */
    page?: number;
    /**
     * The order to get the UTXOs in
     */
    order?: 'asc' | 'desc';
  };
  url: '/utxos/';
};

export type GetUtxosResponses = {
  /**
   * UTXOs
   */
  200: {
    status: string;
    data: {
      Utxos: Array<{
        txHash: string;
        address: string;
        Amounts: Array<{
          unit: string;
          quantity: number | null;
        }>;
        dataHash: string | null;
        inlineDatum: string | null;
        referenceScriptHash: string | null;
        outputIndex: number | null;
        block: string;
      }>;
    };
  };
};

export type GetUtxosResponse = GetUtxosResponses[keyof GetUtxosResponses];

export type GetRpcApiKeysData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Used to paginate through the rpc provider keys
     */
    cursorId?: string;
    /**
     * The number of rpc provider keys to return
     */
    limit?: number;
  };
  url: '/rpc-api-keys/';
};

export type GetRpcApiKeysResponses = {
  /**
   * Blockfrost keys
   */
  200: {
    RpcProviderKeys: Array<{
      id: string;
      rpcProviderApiKey: string;
      rpcProvider: 'Blockfrost';
      createdAt: string;
      updatedAt: string;
      network: 'Preprod' | 'Mainnet';
    }>;
  };
};

export type GetRpcApiKeysResponse =
  GetRpcApiKeysResponses[keyof GetRpcApiKeysResponses];

export type ClientOptions = {
  baseURL: `${string}://${string}` | (string & {});
};
