// This file is auto-generated by @hey-api/openapi-ts

export type GetHealthData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/health/';
};

export type GetHealthResponses = {
    /**
     * Object with status ok, if the server is running
     */
    200: {
        status: string;
    };
};

export type GetHealthResponse = GetHealthResponses[keyof GetHealthResponses];

export type GetApiKeyStatusData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api-key-status/';
};

export type GetApiKeyStatusResponses = {
    /**
     * API key status
     */
    200: {
        status: string;
        data: {
            token: string;
            permission: 'Read' | 'ReadAndPay' | 'Admin';
            usageLimited: boolean;
            networkLimit: Array<'Preprod' | 'Mainnet'>;
            RemainingUsageCredits: Array<{
                unit: string;
                amount: string;
            }>;
            status: 'Active' | 'Revoked';
        };
    };
};

export type GetApiKeyStatusResponse = GetApiKeyStatusResponses[keyof GetApiKeyStatusResponses];

export type GetWalletData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The type of wallet to query
         */
        walletType: 'Selling' | 'Purchasing';
        /**
         * The id of the wallet to query
         */
        id: string;
        /**
         * Whether to include the decrypted secret in the response
         */
        includeSecret?: string;
    };
    url: '/wallet/';
};

export type GetWalletResponses = {
    /**
     * Wallet status
     */
    200: {
        status: string;
        data: {
            Secret?: {
                createdAt: string;
                updatedAt: string;
                mnemonic: string;
            };
            PendingTransaction: {
                createdAt: string;
                updatedAt: string;
                hash: string | null;
                lastCheckedAt: string | null;
            } | null;
            note: string | null;
            walletVkey: string;
            walletAddress: string;
        };
    };
};

export type GetWalletResponse = GetWalletResponses[keyof GetWalletResponses];

export type PostWalletData = {
    body?: {
        /**
         * The network the Cardano wallet will be used on
         */
        network: 'Preprod' | 'Mainnet';
    };
    path?: never;
    query?: never;
    url: '/wallet/';
};

export type PostWalletResponses = {
    /**
     * Wallet created
     */
    200: {
        walletMnemonic: string;
        walletAddress: string;
        walletVkey: string;
    };
};

export type PostWalletResponse = PostWalletResponses[keyof PostWalletResponses];

export type DeleteApiKeyData = {
    body?: {
        /**
         * The id of the API key to be (soft) deleted.
         */
        id: string;
    };
    path?: never;
    query?: never;
    url: '/api-key/';
};

export type DeleteApiKeyErrors = {
    /**
     * Bad Request (possible parameters missing or invalid)
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Internal Server Error
     */
    500: unknown;
};

export type DeleteApiKeyResponses = {
    /**
     * API key deleted
     */
    200: {
        data: {
            id: string;
            token: string;
            permission: 'Read' | 'ReadAndPay' | 'Admin';
            usageLimited: boolean;
            networkLimit: Array<'Preprod' | 'Mainnet'>;
            status: 'Active' | 'Revoked';
            deletedAt: string | null;
        };
        status: string;
    };
};

export type DeleteApiKeyResponse = DeleteApiKeyResponses[keyof DeleteApiKeyResponses];

export type GetApiKeyData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The number of API keys to return
         */
        limit?: number;
        /**
         * Used to paginate through the API keys
         */
        cursorToken?: string;
    };
    url: '/api-key/';
};

export type GetApiKeyErrors = {
    /**
     * Bad Request (possible parameters missing or invalid)
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Internal Server Error
     */
    500: unknown;
};

export type GetApiKeyResponses = {
    /**
     * Api key status
     */
    200: {
        status: string;
        data: {
            ApiKeys: Array<{
                id: string;
                token: string;
                permission: 'Read' | 'ReadAndPay' | 'Admin';
                usageLimited: boolean;
                networkLimit: Array<'Preprod' | 'Mainnet'>;
                RemainingUsageCredits: Array<{
                    unit: string;
                    amount: string;
                }>;
                status: 'Active' | 'Revoked';
            }>;
        };
    };
};

export type GetApiKeyResponse = GetApiKeyResponses[keyof GetApiKeyResponses];

export type PatchApiKeyData = {
    body?: {
        /**
         * The id of the API key to update. Provide either id or apiKey
         */
        id: string;
        /**
         * To change the api key token
         */
        token?: string;
        /**
         * The amount of credits to add or remove from the API key. Only relevant if usageLimited is true.
         */
        UsageCreditsToAddOrRemove?: Array<{
            unit: string;
            amount: string;
        }>;
        /**
         * The status of the API key
         */
        status?: 'Active' | 'Revoked';
        /**
         * The networks the API key is allowed to use
         */
        networkLimit?: Array<'Preprod' | 'Mainnet'>;
    };
    path?: never;
    query?: never;
    url: '/api-key/';
};

export type PatchApiKeyErrors = {
    /**
     * Bad Request (possible parameters missing or invalid)
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Internal Server Error
     */
    500: unknown;
};

export type PatchApiKeyResponses = {
    /**
     * API key deleted
     */
    200: {
        data: {
            id: string;
            token: string;
            permission: 'Read' | 'ReadAndPay' | 'Admin';
            networkLimit: Array<'Preprod' | 'Mainnet'>;
            usageLimited: boolean;
            status: 'Active' | 'Revoked';
        };
        status: string;
    };
};

export type PatchApiKeyResponse = PatchApiKeyResponses[keyof PatchApiKeyResponses];

export type PostApiKeyData = {
    body?: {
        /**
         * Whether the API key is usage limited. Meaning only allowed to use the specified credits or can freely spend
         */
        usageLimited?: string;
        /**
         * The credits allowed to be used by the API key. Only relevant if usageLimited is true.
         */
        UsageCredits: Array<{
            unit: string;
            amount: string;
        }>;
        /**
         * The networks the API key is allowed to use
         */
        networkLimit?: Array<'Preprod' | 'Mainnet'>;
        /**
         * The permission of the API key
         */
        permission?: 'Read' | 'ReadAndPay' | 'Admin';
    };
    path?: never;
    query?: never;
    url: '/api-key/';
};

export type PostApiKeyErrors = {
    /**
     * Bad Request (possible parameters missing or invalid)
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Internal Server Error
     */
    500: unknown;
};

export type PostApiKeyResponses = {
    /**
     * API key deleted
     */
    200: {
        data: {
            id: string;
            token: string;
            permission: 'Read' | 'ReadAndPay' | 'Admin';
            usageLimited: boolean;
            networkLimit: Array<'Preprod' | 'Mainnet'>;
            status: 'Active' | 'Revoked';
        };
        status: string;
    };
};

export type PostApiKeyResponse = PostApiKeyResponses[keyof PostApiKeyResponses];

export type GetPaymentData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The number of payments to return
         */
        limit?: number;
        /**
         * Used to paginate through the payments. If this is provided, cursorId is required
         */
        cursorId?: string;
        /**
         * The network the payments were made on
         */
        network: 'Preprod' | 'Mainnet';
        /**
         * The address of the smart contract where the payments were made to
         */
        smartContractAddress?: string;
        /**
         * Whether to include the full transaction and status history of the payments
         */
        includeHistory?: string;
    };
    url: '/payment/';
};

export type GetPaymentErrors = {
    /**
     * Bad Request (possible parameters missing or invalid)
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Internal Server Error
     */
    500: unknown;
};

export type GetPaymentResponses = {
    /**
     * Payment status
     */
    200: {
        status: string;
        data: {
            Payments: Array<{
                id: string;
                createdAt: string;
                updatedAt: string;
                blockchainIdentifier: string;
                lastCheckedAt: string | null;
                submitResultTime: string;
                unlockTime: string;
                externalDisputeUnlockTime: string;
                requestedById: string;
                resultHash: string;
                inputHash: string;
                cooldownTime: number;
                cooldownTimeOtherParty: number;
                onChainState: 'FundsLocked' | 'FundsOrDatumInvalid' | 'ResultSubmitted' | 'RefundRequested' | 'Disputed' | 'Withdrawn' | 'RefundWithdrawn' | 'DisputedWithdrawn';
                NextAction: {
                    requestedAction: 'None' | 'Ignore' | 'WaitingForManualAction' | 'WaitingForExternalAction' | 'SubmitResultRequested' | 'SubmitResultInitiated' | 'WithdrawRequested' | 'WithdrawInitiated' | 'AuthorizeRefundRequested' | 'AuthorizeRefundInitiated';
                    errorType: 'NetworkError' | 'Unknown';
                    errorNote: string | null;
                    resultHash: string | null;
                };
                CurrentTransaction: {
                    id: string;
                    createdAt: string;
                    updatedAt: string;
                    txHash: string | null;
                } | null;
                TransactionHistory: Array<{
                    id: string;
                    createdAt: string;
                    updatedAt: string;
                    txHash: string | null;
                }> | null;
                RequestedFunds: Array<{
                    id: string;
                    createdAt: string;
                    updatedAt: string;
                    amount: string;
                    unit: string;
                }>;
                PaymentSource: {
                    id: string;
                    network: 'Preprod' | 'Mainnet';
                    smartContractAddress: string;
                    paymentType: 'Web3CardanoV1';
                };
                BuyerWallet: {
                    id: string;
                    walletVkey: string;
                } | null;
                SmartContractWallet: {
                    id: string;
                    walletVkey: string;
                    walletAddress: string;
                } | null;
                metadata: string | null;
            }>;
        };
    };
};

export type GetPaymentResponse = GetPaymentResponses[keyof GetPaymentResponses];

export type PostPaymentData = {
    body?: {
        inputHash: string;
        /**
         * The network the payment will be received on
         */
        network: 'Preprod' | 'Mainnet';
        /**
         * The identifier of the agent that will be paid
         */
        agentIdentifier: string;
        /**
         * The amounts of the payment
         */
        RequestedFunds: Array<{
            amount: string;
            unit: string;
        }>;
        /**
         * The type of payment contract used
         */
        paymentType: 'Web3CardanoV1';
        /**
         * The address of the smart contract where the payment will be made to
         */
        smartContractAddress?: string;
        /**
         * The time after which the payment has to be submitted to the smart contract
         */
        submitResultTime?: Date;
        /**
         * The time after which the payment will be unlocked
         */
        unlockTime?: Date;
        /**
         * The time after which the payment will be unlocked for external dispute
         */
        externalDisputeUnlockTime?: Date;
        /**
         * Metadata to be stored with the payment request
         */
        metadata?: string;
        /**
         * The cuid2 identifier of the purchaser of the payment
         */
        identifierFromPurchaser: string;
    };
    path?: never;
    query?: never;
    url: '/payment/';
};

export type PostPaymentErrors = {
    /**
     * Bad Request (possible parameters missing or invalid)
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Internal Server Error
     */
    500: unknown;
};

export type PostPaymentResponses = {
    /**
     * Payment request created
     */
    200: {
        data: {
            id: string;
            createdAt: string;
            updatedAt: string;
            blockchainIdentifier: string;
            submitResultTime: string;
            unlockTime: string;
            externalDisputeUnlockTime: string;
            lastCheckedAt: string | null;
            requestedById: string;
            inputHash: string;
            resultHash: string;
            onChainState: 'FundsLocked' | 'FundsOrDatumInvalid' | 'ResultSubmitted' | 'RefundRequested' | 'Disputed' | 'Withdrawn' | 'RefundWithdrawn' | 'DisputedWithdrawn';
            NextAction: {
                requestedAction: 'None' | 'Ignore' | 'WaitingForManualAction' | 'WaitingForExternalAction' | 'SubmitResultRequested' | 'SubmitResultInitiated' | 'WithdrawRequested' | 'WithdrawInitiated' | 'AuthorizeRefundRequested' | 'AuthorizeRefundInitiated';
                resultHash: string | null;
                errorType: 'NetworkError' | 'Unknown';
                errorNote: string | null;
            };
            RequestedFunds: Array<{
                id: string;
                createdAt: string;
                updatedAt: string;
                amount: string;
                unit: string;
            }>;
            PaymentSource: {
                id: string;
                network: 'Preprod' | 'Mainnet';
                smartContractAddress: string;
                paymentType: 'Web3CardanoV1';
            };
            BuyerWallet: {
                id: string;
                walletVkey: string;
            } | null;
            SmartContractWallet: {
                id: string;
                walletVkey: string;
                walletAddress: string;
            } | null;
            metadata: string | null;
        };
        status: string;
    };
};

export type PostPaymentResponse = PostPaymentResponses[keyof PostPaymentResponses];

export type PostPaymentSubmitResultData = {
    body?: {
        /**
         * The network the payment was received on
         */
        network: 'Preprod' | 'Mainnet';
        /**
         * The address of the smart contract where the payment was made to
         */
        smartContractAddress?: string;
        /**
         * The hash of the AI agent result to be submitted
         */
        submitResultHash: string;
        /**
         * The identifier of the payment
         */
        blockchainIdentifier: string;
    };
    path?: never;
    query?: never;
    url: '/payment/submit-result';
};

export type PostPaymentSubmitResultErrors = {
    /**
     * Bad Request (possible parameters missing or invalid)
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Internal Server Error
     */
    500: unknown;
};

export type PostPaymentSubmitResultResponses = {
    /**
     * Payment updated
     */
    200: {
        data: {
            id: string;
            createdAt: string;
            updatedAt: string;
            blockchainIdentifier: string;
            submitResultTime: string;
            unlockTime: string;
            externalDisputeUnlockTime: string;
            lastCheckedAt: string | null;
            requestedById: string;
            resultHash: string;
            inputHash: string;
            onChainState: 'FundsLocked' | 'FundsOrDatumInvalid' | 'ResultSubmitted' | 'RefundRequested' | 'Disputed' | 'Withdrawn' | 'RefundWithdrawn' | 'DisputedWithdrawn';
            NextAction: {
                requestedAction: 'None' | 'Ignore' | 'WaitingForManualAction' | 'WaitingForExternalAction' | 'SubmitResultRequested' | 'SubmitResultInitiated' | 'WithdrawRequested' | 'WithdrawInitiated' | 'AuthorizeRefundRequested' | 'AuthorizeRefundInitiated';
                errorType: 'NetworkError' | 'Unknown';
                errorNote: string | null;
                resultHash: string | null;
            };
            RequestedFunds: Array<{
                id: string;
                createdAt: string;
                updatedAt: string;
                amount: string;
                unit: string;
            }>;
            PaymentSource: {
                id: string;
                network: 'Preprod' | 'Mainnet';
                smartContractAddress: string;
                paymentType: 'Web3CardanoV1';
            };
            BuyerWallet: {
                id: string;
                walletVkey: string;
            } | null;
            SmartContractWallet: {
                id: string;
                walletVkey: string;
                walletAddress: string;
            } | null;
            metadata: string | null;
        };
        status: string;
    };
};

export type PostPaymentSubmitResultResponse = PostPaymentSubmitResultResponses[keyof PostPaymentSubmitResultResponses];

export type PostPaymentAuthorizeRefundData = {
    body?: {
        /**
         * The identifier of the purchase to be refunded
         */
        blockchainIdentifier: string;
        /**
         * The network the Cardano wallet will be used on
         */
        network: 'Preprod' | 'Mainnet';
        /**
         * The address of the smart contract holding the purchase
         */
        paymentContractAddress?: string;
    };
    path?: never;
    query?: never;
    url: '/payment/authorize-refund';
};

export type PostPaymentAuthorizeRefundErrors = {
    /**
     * Bad Request (possible parameters missing or invalid)
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Internal Server Error
     */
    500: unknown;
};

export type PostPaymentAuthorizeRefundResponses = {
    /**
     * API key deleted
     */
    200: {
        data: {
            id: string;
            createdAt: string;
            updatedAt: string;
            blockchainIdentifier: string;
            submitResultTime: string;
            unlockTime: string;
            externalDisputeUnlockTime: string;
            lastCheckedAt: string | null;
            requestedById: string;
            resultHash: string;
            inputHash: string;
            onChainState: 'FundsLocked' | 'FundsOrDatumInvalid' | 'ResultSubmitted' | 'RefundRequested' | 'Disputed' | 'Withdrawn' | 'RefundWithdrawn' | 'DisputedWithdrawn';
            NextAction: {
                requestedAction: 'None' | 'Ignore' | 'WaitingForManualAction' | 'WaitingForExternalAction' | 'SubmitResultRequested' | 'SubmitResultInitiated' | 'WithdrawRequested' | 'WithdrawInitiated' | 'AuthorizeRefundRequested' | 'AuthorizeRefundInitiated';
                errorType: 'NetworkError' | 'Unknown';
                errorNote: string | null;
                resultHash: string | null;
            };
            RequestedFunds: Array<{
                id: string;
                createdAt: string;
                updatedAt: string;
                amount: string;
                unit: string;
            }>;
            PaymentSource: {
                id: string;
                network: 'Preprod' | 'Mainnet';
                smartContractAddress: string;
                paymentType: 'Web3CardanoV1';
            };
            BuyerWallet: {
                id: string;
                walletVkey: string;
            } | null;
            SmartContractWallet: {
                id: string;
                walletVkey: string;
                walletAddress: string;
            } | null;
            metadata: string | null;
        };
        status: string;
    };
};

export type PostPaymentAuthorizeRefundResponse = PostPaymentAuthorizeRefundResponses[keyof PostPaymentAuthorizeRefundResponses];

export type GetPurchaseData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The number of purchases to return
         */
        limit?: number;
        /**
         * Used to paginate through the purchases. If this is provided, cursorId is required
         */
        cursorId?: string;
        /**
         * The network the purchases were made on
         */
        network: 'Preprod' | 'Mainnet';
        /**
         * The address of the smart contract where the purchases were made to
         */
        smartContractAddress?: string;
        /**
         * Whether to include the full transaction and status history of the purchases
         */
        includeHistory?: string;
    };
    url: '/purchase/';
};

export type GetPurchaseErrors = {
    /**
     * Bad Request (possible parameters missing or invalid)
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Internal Server Error
     */
    500: unknown;
};

export type GetPurchaseResponses = {
    /**
     * Purchase status
     */
    200: {
        status: string;
        data: {
            Purchases: Array<{
                id: string;
                createdAt: string;
                updatedAt: string;
                blockchainIdentifier: string;
                lastCheckedAt: string | null;
                submitResultTime: string;
                unlockTime: string;
                externalDisputeUnlockTime: string;
                requestedById: string;
                onChainState: 'FundsLocked' | 'FundsOrDatumInvalid' | 'ResultSubmitted' | 'RefundRequested' | 'Disputed' | 'Withdrawn' | 'RefundWithdrawn' | 'DisputedWithdrawn';
                cooldownTime: number;
                cooldownTimeOtherParty: number;
                inputHash: string;
                resultHash: string;
                NextAction: {
                    inputHash: string;
                    requestedAction: 'None' | 'Ignore' | 'WaitingForManualAction' | 'WaitingForExternalAction' | 'FundsLockingRequested' | 'FundsLockingInitiated' | 'SetRefundRequestedRequested' | 'SetRefundRequestedInitiated' | 'UnSetRefundRequestedRequested' | 'UnSetRefundRequestedInitiated' | 'WithdrawRefundRequested' | 'WithdrawRefundInitiated';
                    errorType: 'NetworkError' | 'InsufficientFunds' | 'Unknown';
                    errorNote: string | null;
                };
                CurrentTransaction: {
                    id: string;
                    createdAt: string;
                    updatedAt: string;
                    txHash: string;
                    status: 'Pending' | 'Confirmed' | 'FailedViaTimeout';
                } | null;
                TransactionHistory: Array<{
                    id: string;
                    createdAt: string;
                    updatedAt: string;
                    txHash: string;
                    status: 'Pending' | 'Confirmed' | 'FailedViaTimeout';
                }>;
                PaidFunds: Array<{
                    id: string;
                    createdAt: string;
                    updatedAt: string;
                    amount: string;
                    unit: string;
                }>;
                PaymentSource: {
                    id: string;
                    network: 'Preprod' | 'Mainnet';
                    smartContractAddress: string;
                    paymentType: 'Web3CardanoV1';
                };
                SellerWallet: {
                    id: string;
                    walletVkey: string;
                } | null;
                SmartContractWallet: {
                    id: string;
                    walletVkey: string;
                    walletAddress: string;
                } | null;
                metadata: string | null;
            }>;
        };
    };
};

export type GetPurchaseResponse = GetPurchaseResponses[keyof GetPurchaseResponses];

export type PostPurchaseData = {
    body?: {
        /**
         * The identifier of the purchase. Is provided by the seller
         */
        blockchainIdentifier: string;
        /**
         * The network the transaction will be made on
         */
        network: 'Preprod' | 'Mainnet';
        inputHash: string;
        /**
         * The verification key of the seller
         */
        sellerVkey: string;
        /**
         * The identifier of the agent that is being purchased
         */
        agentIdentifier: string;
        /**
         * The address of the smart contract where the purchase will be made to
         */
        smartContractAddress?: string;
        /**
         * The amounts to be paid for the purchase
         */
        Amounts: Array<{
            amount: string;
            unit: string;
        }>;
        /**
         * The payment type of smart contract used
         */
        paymentType: 'Web3CardanoV1';
        /**
         * The time after which the purchase will be unlocked. In unix time (number)
         */
        unlockTime: string;
        /**
         * The time after which the purchase will be unlocked for external dispute. In unix time (number)
         */
        externalDisputeUnlockTime: string;
        /**
         * The time by which the result has to be submitted. In unix time (number)
         */
        submitResultTime: string;
        /**
         * Metadata to be stored with the purchase request
         */
        metadata?: string;
        /**
         * The cuid2 identifier of the purchaser of the purchase
         */
        identifierFromPurchaser: string;
    };
    path?: never;
    query?: never;
    url: '/purchase/';
};

export type PostPurchaseErrors = {
    /**
     * Bad Request (possible parameters missing or invalid)
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Internal Server Error
     */
    500: unknown;
};

export type PostPurchaseResponses = {
    /**
     * Purchase request created
     */
    200: {
        data: {
            id: string;
            createdAt: string;
            updatedAt: string;
            blockchainIdentifier: string;
            lastCheckedAt: string | null;
            submitResultTime: string;
            unlockTime: string;
            externalDisputeUnlockTime: string;
            requestedById: string;
            resultHash: string;
            inputHash: string;
            onChainState: 'FundsLocked' | 'FundsOrDatumInvalid' | 'ResultSubmitted' | 'RefundRequested' | 'Disputed' | 'Withdrawn' | 'RefundWithdrawn' | 'DisputedWithdrawn';
            NextAction: {
                requestedAction: 'None' | 'Ignore' | 'WaitingForManualAction' | 'WaitingForExternalAction' | 'FundsLockingRequested' | 'FundsLockingInitiated' | 'SetRefundRequestedRequested' | 'SetRefundRequestedInitiated' | 'UnSetRefundRequestedRequested' | 'UnSetRefundRequestedInitiated' | 'WithdrawRefundRequested' | 'WithdrawRefundInitiated';
                errorType: 'NetworkError' | 'InsufficientFunds' | 'Unknown';
                errorNote: string | null;
            };
            CurrentTransaction: {
                id: string;
                createdAt: string;
                updatedAt: string;
                txHash: string;
                status: 'Pending' | 'Confirmed' | 'FailedViaTimeout';
            } | null;
            PaidFunds: Array<{
                id: string;
                createdAt: string;
                updatedAt: string;
                amount: string;
                unit: string;
            }>;
            PaymentSource: {
                id: string;
                network: 'Preprod' | 'Mainnet';
                smartContractAddress: string;
                paymentType: 'Web3CardanoV1';
            };
            SellerWallet: {
                id: string;
                walletVkey: string;
            } | null;
            SmartContractWallet: {
                id: string;
                walletVkey: string;
                walletAddress: string;
            } | null;
            metadata: string | null;
        };
        status: string;
    };
};

export type PostPurchaseResponse = PostPurchaseResponses[keyof PostPurchaseResponses];

export type PostPurchaseRequestRefundData = {
    body?: {
        /**
         * The identifier of the purchase to be refunded
         */
        blockchainIdentifier: string;
        /**
         * The network the Cardano wallet will be used on
         */
        network: 'Preprod' | 'Mainnet';
        /**
         * The address of the smart contract holding the purchase
         */
        smartContractAddress?: string;
    };
    path?: never;
    query?: never;
    url: '/purchase/request-refund';
};

export type PostPurchaseRequestRefundErrors = {
    /**
     * Bad Request (possible parameters missing or invalid)
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Internal Server Error
     */
    500: unknown;
};

export type PostPurchaseRequestRefundResponses = {
    /**
     * API key deleted
     */
    200: {
        data: {
            id: string;
            createdAt: string;
            updatedAt: string;
            blockchainIdentifier: string;
            lastCheckedAt: string | null;
            submitResultTime: string;
            unlockTime: string;
            externalDisputeUnlockTime: string;
            requestedById: string;
            resultHash: string;
            onChainState: 'FundsLocked' | 'FundsOrDatumInvalid' | 'ResultSubmitted' | 'RefundRequested' | 'Disputed' | 'Withdrawn' | 'RefundWithdrawn' | 'DisputedWithdrawn';
            NextAction: {
                requestedAction: 'None' | 'Ignore' | 'WaitingForManualAction' | 'WaitingForExternalAction' | 'FundsLockingRequested' | 'FundsLockingInitiated' | 'SetRefundRequestedRequested' | 'SetRefundRequestedInitiated' | 'UnSetRefundRequestedRequested' | 'UnSetRefundRequestedInitiated' | 'WithdrawRefundRequested' | 'WithdrawRefundInitiated';
                errorType: 'NetworkError' | 'InsufficientFunds' | 'Unknown';
                errorNote: string | null;
            };
            CurrentTransaction: {
                id: string;
                createdAt: string;
                updatedAt: string;
                txHash: string;
                status: 'Pending' | 'Confirmed' | 'FailedViaTimeout';
            } | null;
            PaidFunds: Array<{
                id: string;
                createdAt: string;
                updatedAt: string;
                amount: string;
                unit: string;
            }>;
            PaymentSource: {
                id: string;
                network: 'Preprod' | 'Mainnet';
                smartContractAddress: string;
                paymentType: 'Web3CardanoV1';
            };
            SellerWallet: {
                id: string;
                walletVkey: string;
            } | null;
            SmartContractWallet: {
                id: string;
                walletVkey: string;
                walletAddress: string;
            } | null;
            metadata: string | null;
        };
        status: string;
    };
};

export type PostPurchaseRequestRefundResponse = PostPurchaseRequestRefundResponses[keyof PostPurchaseRequestRefundResponses];

export type PostPurchaseCancelRefundRequestData = {
    body?: {
        /**
         * The identifier of the purchase to be refunded
         */
        blockchainIdentifier: string;
        /**
         * The network the Cardano wallet will be used on
         */
        network: 'Preprod' | 'Mainnet';
        /**
         * The address of the smart contract holding the purchase
         */
        smartContractAddress?: string;
    };
    path?: never;
    query?: never;
    url: '/purchase/cancel-refund-request';
};

export type PostPurchaseCancelRefundRequestErrors = {
    /**
     * Bad Request (possible parameters missing or invalid)
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Internal Server Error
     */
    500: unknown;
};

export type PostPurchaseCancelRefundRequestResponses = {
    /**
     * API key deleted
     */
    200: {
        data: {
            id: string;
            createdAt: string;
            updatedAt: string;
            blockchainIdentifier: string;
            lastCheckedAt: string | null;
            submitResultTime: string;
            unlockTime: string;
            externalDisputeUnlockTime: string;
            requestedById: string;
            resultHash: string;
            onChainState: 'FundsLocked' | 'FundsOrDatumInvalid' | 'ResultSubmitted' | 'RefundRequested' | 'Disputed' | 'Withdrawn' | 'RefundWithdrawn' | 'DisputedWithdrawn';
            NextAction: {
                requestedAction: 'None' | 'Ignore' | 'WaitingForManualAction' | 'WaitingForExternalAction' | 'FundsLockingRequested' | 'FundsLockingInitiated' | 'SetRefundRequestedRequested' | 'SetRefundRequestedInitiated' | 'UnSetRefundRequestedRequested' | 'UnSetRefundRequestedInitiated' | 'WithdrawRefundRequested' | 'WithdrawRefundInitiated';
                errorType: 'NetworkError' | 'InsufficientFunds' | 'Unknown';
                errorNote: string | null;
            };
            CurrentTransaction: {
                id: string;
                createdAt: string;
                updatedAt: string;
                txHash: string;
                status: 'Pending' | 'Confirmed' | 'FailedViaTimeout';
            } | null;
            PaidFunds: Array<{
                id: string;
                createdAt: string;
                updatedAt: string;
                amount: string;
                unit: string;
            }>;
            PaymentSource: {
                id: string;
                network: 'Preprod' | 'Mainnet';
                smartContractAddress: string;
                paymentType: 'Web3CardanoV1';
            };
            SellerWallet: {
                id: string;
                walletVkey: string;
            } | null;
            SmartContractWallet: {
                id: string;
                walletVkey: string;
                walletAddress: string;
            } | null;
            metadata: string | null;
        };
        status: string;
    };
};

export type PostPurchaseCancelRefundRequestResponse = PostPurchaseCancelRefundRequestResponses[keyof PostPurchaseCancelRefundRequestResponses];

export type GetRegistryWalletData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The payment key of the wallet to be queried
         */
        walletVKey: string;
        /**
         * The Cardano network used to register the agent on
         */
        network: 'Preprod' | 'Mainnet';
        /**
         * The smart contract address of the payment source to which the registration belongs
         */
        smartContractAddress?: string;
    };
    url: '/registry/wallet';
};

export type GetRegistryWalletResponses = {
    /**
     * Agent metadata
     */
    200: {
        status: string;
        data: {
            Assets: Array<{
                policyId: string;
                assetName: string;
                agentIdentifier: string;
                Metadata: {
                    name: string;
                    description?: string | null;
                    apiBaseUrl: string;
                    ExampleOutputs: Array<{
                        name: string;
                        mimeType: string;
                        url: string;
                    }>;
                    Tags: Array<string>;
                    Capability?: {
                        name?: string | null;
                        version?: string | null;
                    } | null;
                    Author: {
                        name: string;
                        contactEmail?: string | null;
                        contactOther?: string | null;
                        organization?: string | null;
                    };
                    Legal?: {
                        privacyPolicy?: string | null;
                        terms?: string | null;
                        other?: string | null;
                    } | null;
                    AgentPricing: {
                        pricingType: 'Fixed';
                        Pricing: Array<{
                            amount: string;
                            unit: string;
                        }>;
                    };
                    image: string;
                    metadataVersion: number;
                };
            }>;
        };
    };
};

export type GetRegistryWalletResponse = GetRegistryWalletResponses[keyof GetRegistryWalletResponses];

export type DeleteRegistryData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The identifier of the registration (asset) to be deregistered
         */
        agentIdentifier: string;
        /**
         * The network the registration was made on
         */
        network: 'Preprod' | 'Mainnet';
        /**
         * The smart contract address of the payment contract to which the registration belongs
         */
        smartContractAddress?: string;
    };
    url: '/registry/';
};

export type DeleteRegistryResponses = {
    /**
     * Payment source deleted
     */
    200: {
        status: string;
        data: {
            id: string;
            name: string;
            apiBaseUrl: string;
            Capability: {
                name: string | null;
                version: string | null;
            };
            Author: {
                name: string;
                contactEmail: string | null;
                contactOther: string | null;
                organization: string | null;
            };
            Legal: {
                privacyPolicy: string | null;
                terms: string | null;
                other: string | null;
            };
            description: string | null;
            Tags: Array<string>;
            SmartContractWallet: {
                walletVkey: string;
                walletAddress: string;
            };
            state: 'RegistrationRequested' | 'RegistrationInitiated' | 'RegistrationConfirmed' | 'RegistrationFailed' | 'DeregistrationRequested' | 'DeregistrationInitiated' | 'DeregistrationConfirmed' | 'DeregistrationFailed';
            ExampleOutputs: Array<{
                name: string;
                url: string;
                mimeType: string;
            }>;
            AgentPricing: {
                pricingType: 'Fixed';
                Pricing: Array<{
                    unit: string;
                    amount: string;
                }>;
            };
        };
    };
};

export type DeleteRegistryResponse = DeleteRegistryResponses[keyof DeleteRegistryResponses];

export type GetRegistryData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The cursor id to paginate through the results
         */
        cursorId?: string;
        /**
         * The Cardano network used to register the agent on
         */
        network: 'Preprod' | 'Mainnet';
        /**
         * The smart contract address of the payment source to which the registration belongs
         */
        smartContractAddress?: string;
    };
    url: '/registry/';
};

export type GetRegistryResponses = {
    /**
     * Agent metadata
     */
    200: {
        status: string;
        data: {
            Assets: Array<{
                id: string;
                name: string;
                description: string | null;
                apiBaseUrl: string;
                Capability: {
                    name: string | null;
                    version: string | null;
                };
                Author: {
                    name: string;
                    contactEmail: string | null;
                    contactOther: string | null;
                    organization: string | null;
                };
                Legal: {
                    privacyPolicy: string | null;
                    terms: string | null;
                    other: string | null;
                };
                state: 'RegistrationRequested' | 'RegistrationInitiated' | 'RegistrationConfirmed' | 'RegistrationFailed' | 'DeregistrationRequested' | 'DeregistrationInitiated' | 'DeregistrationConfirmed' | 'DeregistrationFailed';
                Tags: Array<string>;
                createdAt: string;
                updatedAt: string;
                lastCheckedAt: string | null;
                ExampleOutputs: Array<{
                    name: string;
                    url: string;
                    mimeType: string;
                }>;
                agentIdentifier: string | null;
                AgentPricing: {
                    pricingType: 'Fixed';
                    Pricing: Array<{
                        amount: string;
                        unit: string;
                    }>;
                };
                SmartContractWallet: {
                    walletVkey: string;
                    walletAddress: string;
                };
                CurrentTransaction: {
                    txHash: string;
                    status: 'Pending' | 'Confirmed' | 'FailedViaTimeout';
                } | null;
            }>;
        };
    };
};

export type GetRegistryResponse = GetRegistryResponses[keyof GetRegistryResponses];

export type PostRegistryData = {
    body?: {
        /**
         * The Cardano network used to register the agent on
         */
        network: 'Preprod' | 'Mainnet';
        /**
         * The smart contract address of the payment contract to be registered for
         */
        smartContractAddress?: string;
        /**
         * The payment key of a specific wallet used for the registration
         */
        sellingWalletVkey: string;
        ExampleOutputs: Array<{
            name: string;
            url: string;
            mimeType: string;
        }>;
        /**
         * Tags used in the registry metadata
         */
        Tags: Array<string>;
        /**
         * Name of the agent
         */
        name: string;
        /**
         * Base URL of the agent, to request interactions
         */
        apiBaseUrl: string;
        /**
         * Description of the agent
         */
        description: string;
        /**
         * Provide information about the used AI model and version
         */
        Capability: {
            name: string;
            version: string;
        };
        AgentPricing: {
            pricingType: 'Fixed';
            /**
             * Price for a default interaction
             */
            Pricing: Array<{
                unit: string;
                amount: string;
            }>;
        };
        /**
         * Legal information about the agent
         */
        Legal?: {
            privacyPolicy?: string;
            terms?: string;
            other?: string;
        };
        /**
         * Author information about the agent
         */
        Author: {
            name: string;
            contactEmail?: string;
            contactOther?: string;
            organization?: string;
        };
    };
    path?: never;
    query?: never;
    url: '/registry/';
};

export type PostRegistryResponses = {
    /**
     * Agent registered
     */
    200: {
        status: string;
        data: {
            id: string;
            name: string;
            apiBaseUrl: string;
            Capability: {
                name: string | null;
                version: string | null;
            };
            Legal: {
                privacyPolicy: string | null;
                terms: string | null;
                other: string | null;
            };
            Author: {
                name: string;
                contactEmail: string | null;
                contactOther: string | null;
                organization: string | null;
            };
            description: string | null;
            Tags: Array<string>;
            state: 'RegistrationRequested' | 'RegistrationInitiated' | 'RegistrationConfirmed' | 'RegistrationFailed' | 'DeregistrationRequested' | 'DeregistrationInitiated' | 'DeregistrationConfirmed' | 'DeregistrationFailed';
            SmartContractWallet: {
                walletVkey: string;
                walletAddress: string;
            };
            ExampleOutputs: Array<{
                name: string;
                url: string;
                mimeType: string;
            }>;
            AgentPricing: {
                pricingType: 'Fixed';
                Pricing: Array<{
                    unit: string;
                    amount: string;
                }>;
            };
        };
    };
};

export type PostRegistryResponse = PostRegistryResponses[keyof PostRegistryResponses];

export type GetPaymentSourceData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The number of payment sources to return
         */
        take?: number;
        /**
         * Used to paginate through the payment sources
         */
        cursorId?: string;
    };
    url: '/payment-source/';
};

export type GetPaymentSourceResponses = {
    /**
     * Payment source status
     */
    200: {
        status: string;
        data: {
            PaymentSources: Array<{
                id: string;
                createdAt: string;
                updatedAt: string;
                network: 'Preprod' | 'Mainnet';
                smartContractAddress: string;
                paymentType: 'Web3CardanoV1';
                lastIdentifierChecked: string | null;
                lastCheckedAt: string | null;
                AdminWallets: Array<{
                    walletAddress: string;
                    order: number;
                }>;
                PurchasingWallets: Array<{
                    id: string;
                    walletVkey: string;
                    walletAddress: string;
                    collectionAddress: string | null;
                    note: string | null;
                }>;
                SellingWallets: Array<{
                    id: string;
                    walletVkey: string;
                    walletAddress: string;
                    collectionAddress: string | null;
                    note: string | null;
                }>;
                FeeReceiverNetworkWallet: {
                    walletAddress: string;
                };
                feeRatePermille: number;
            }>;
        };
    };
};

export type GetPaymentSourceResponse = GetPaymentSourceResponses[keyof GetPaymentSourceResponses];

export type DeletePaymentSourceExtendedData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The id of the payment source to be deleted
         */
        id: string;
    };
    url: '/payment-source-extended/';
};

export type DeletePaymentSourceExtendedResponses = {
    /**
     * Payment source deleted
     */
    200: {
        status: string;
        data: {
            id: string;
        };
    };
};

export type DeletePaymentSourceExtendedResponse = DeletePaymentSourceExtendedResponses[keyof DeletePaymentSourceExtendedResponses];

export type GetPaymentSourceExtendedData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The number of payment sources to return
         */
        take?: number;
        /**
         * Used to paginate through the payment sources
         */
        cursorId?: string;
    };
    url: '/payment-source-extended/';
};

export type GetPaymentSourceExtendedResponses = {
    /**
     * Payment source status
     */
    200: {
        status: string;
        data: {
            ExtendedPaymentSources: Array<{
                id: string;
                createdAt: string;
                updatedAt: string;
                network: 'Preprod' | 'Mainnet';
                smartContractAddress: string;
                paymentType: 'Web3CardanoV1';
                PaymentSourceConfig: {
                    rpcProviderApiKey: string;
                    rpcProvider: 'Blockfrost';
                };
                lastIdentifierChecked: string | null;
                syncInProgress: boolean;
                lastCheckedAt: string | null;
                AdminWallets: Array<{
                    walletAddress: string;
                    order: number;
                }>;
                PurchasingWallets: Array<{
                    id: string;
                    walletVkey: string;
                    walletAddress: string;
                    collectionAddress: string | null;
                    note: string | null;
                }>;
                SellingWallets: Array<{
                    id: string;
                    walletVkey: string;
                    walletAddress: string;
                    collectionAddress: string | null;
                    note: string | null;
                }>;
                FeeReceiverNetworkWallet: {
                    walletAddress: string;
                };
                feeRatePermille: number;
            }>;
        };
    };
};

export type GetPaymentSourceExtendedResponse = GetPaymentSourceExtendedResponses[keyof GetPaymentSourceExtendedResponses];

export type PatchPaymentSourceExtendedData = {
    body?: {
        /**
         * The id of the payment source to be updated
         */
        id: string;
        PaymentSourceConfig?: {
            /**
             * The rpc provider (blockfrost) api key to be used for the payment source
             */
            rpcProviderApiKey: string;
            /**
             * The rpc provider to be used for the payment contract
             */
            rpcProvider: 'Blockfrost';
        };
        /**
         * The mnemonic of the purchasing wallets to be added
         */
        AddPurchasingWallets?: Array<{
            walletMnemonic: string;
            note: string;
            /**
             * The collection address of the purchasing wallet
             */
            collectionAddress: string | null;
        }>;
        /**
         * The mnemonic of the selling wallets to be added
         */
        AddSellingWallets?: Array<{
            walletMnemonic: string;
            note: string;
            /**
             * The collection address of the selling wallet
             */
            collectionAddress: string | null;
        }>;
        /**
         * The ids of the purchasing wallets to be removed. Please backup the mnemonic of the old wallet before removing it.
         */
        RemovePurchasingWallets?: Array<{
            id: string;
        }>;
        /**
         * The ids of the selling wallets to be removed. Please backup the mnemonic of the old wallet before removing it.
         */
        RemoveSellingWallets?: Array<{
            id: string;
        }>;
        /**
         * The latest identifier of the payment source. Usually should not be changed
         */
        lastIdentifierChecked?: string | null;
    };
    path?: never;
    query?: never;
    url: '/payment-source-extended/';
};

export type PatchPaymentSourceExtendedResponses = {
    /**
     * Payment contract updated
     */
    200: {
        status: string;
        data: {
            id: string;
            createdAt: string;
            updatedAt: string;
            network: 'Preprod' | 'Mainnet';
            smartContractAddress: string;
            paymentType: 'Web3CardanoV1';
            PaymentSourceConfig: {
                rpcProviderApiKey: string;
                rpcProvider: 'Blockfrost';
            };
            lastIdentifierChecked: string | null;
            syncInProgress: boolean;
            lastCheckedAt: string | null;
            AdminWallets: Array<{
                walletAddress: string;
                order: number;
            }>;
            PurchasingWallets: Array<{
                id: string;
                walletVkey: string;
                walletAddress: string;
                collectionAddress: string | null;
                note: string | null;
            }>;
            SellingWallets: Array<{
                id: string;
                walletVkey: string;
                walletAddress: string;
                collectionAddress: string | null;
                note: string | null;
            }>;
            FeeReceiverNetworkWallet: {
                walletAddress: string;
            };
            feeRatePermille: number;
        };
    };
};

export type PatchPaymentSourceExtendedResponse = PatchPaymentSourceExtendedResponses[keyof PatchPaymentSourceExtendedResponses];

export type PostPaymentSourceExtendedData = {
    body?: {
        /**
         * The network the payment source will be used on
         */
        network: 'Preprod' | 'Mainnet';
        /**
         * The type of payment source used
         */
        paymentType: 'Web3CardanoV1';
        PaymentSourceConfig: {
            /**
             * The rpc provider (blockfrost) api key to be used for the payment source
             */
            rpcProviderApiKey: string;
            /**
             * The rpc provider to be used for the payment source
             */
            rpcProvider: 'Blockfrost';
        };
        /**
         * The fee in permille to be used for the payment source. The default contract uses 50 (5%)
         */
        feeRatePermille: number | null;
        /**
         * The wallet addresses of the admin wallets (exactly 3)
         */
        AdminWallets: [
            {
                walletAddress: string;
            },
            {
                walletAddress: string;
            },
            {
                walletAddress: string;
            }
        ];
        /**
         * The wallet address of the network fee receiver wallet
         */
        FeeReceiverNetworkWallet: {
            walletAddress: string;
        };
        /**
         * The mnemonic of the purchasing wallets to be added. Please backup the mnemonic of the wallets.
         */
        PurchasingWallets: Array<{
            walletMnemonic: string;
            /**
             * The collection address of the purchasing wallet
             */
            collectionAddress: string | null;
            note: string;
        }>;
        /**
         * The mnemonic of the selling wallets to be added. Please backup the mnemonic of the wallets.
         */
        SellingWallets: Array<{
            walletMnemonic: string;
            /**
             * The collection address of the selling wallet
             */
            collectionAddress: string | null;
            note: string;
        }>;
    };
    path?: never;
    query?: never;
    url: '/payment-source-extended/';
};

export type PostPaymentSourceExtendedResponses = {
    /**
     * Payment source created
     */
    200: {
        status: string;
        data: {
            id: string;
            createdAt: string;
            updatedAt: string;
            network: 'Preprod' | 'Mainnet';
            smartContractAddress: string;
            paymentType: 'Web3CardanoV1';
            PaymentSourceConfig: {
                rpcProviderApiKey: string;
                rpcProvider: 'Blockfrost';
            };
            lastIdentifierChecked: string | null;
            syncInProgress: boolean;
            lastCheckedAt: string | null;
            AdminWallets: Array<{
                walletAddress: string;
                order: number;
            }>;
            PurchasingWallets: Array<{
                id: string;
                walletVkey: string;
                walletAddress: string;
                collectionAddress: string | null;
                note: string | null;
            }>;
            SellingWallets: Array<{
                id: string;
                walletVkey: string;
                walletAddress: string;
                collectionAddress: string | null;
                note: string | null;
            }>;
            FeeReceiverNetworkWallet: {
                walletAddress: string;
            };
            feeRatePermille: number;
        };
    };
};

export type PostPaymentSourceExtendedResponse = PostPaymentSourceExtendedResponses[keyof PostPaymentSourceExtendedResponses];

export type GetUtxosData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The address to get the UTXOs for
         */
        address: string;
        network: 'Preprod' | 'Mainnet';
        /**
         * The number of UTXOs to get
         */
        count?: number;
        /**
         * The page number to get
         */
        page?: number;
        /**
         * The order to get the UTXOs in
         */
        order?: 'asc' | 'desc';
    };
    url: '/utxos/';
};

export type GetUtxosResponses = {
    /**
     * UTXOs
     */
    200: {
        status: string;
        data: {
            Utxos: Array<{
                txHash: string;
                address: string;
                Amounts: Array<{
                    unit: string;
                    quantity: number | null;
                }>;
                dataHash: string | null;
                inlineDatum: string | null;
                referenceScriptHash: string | null;
                outputIndex: number | null;
                block: string;
            }>;
        };
    };
};

export type GetUtxosResponse = GetUtxosResponses[keyof GetUtxosResponses];

export type GetRpcApiKeysData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Used to paginate through the rpc provider keys
         */
        cursorId?: string;
        /**
         * The number of rpc provider keys to return
         */
        limit?: number;
    };
    url: '/rpc-api-keys/';
};

export type GetRpcApiKeysResponses = {
    /**
     * Blockfrost keys
     */
    200: {
        RpcProviderKeys: Array<{
            id: string;
            rpcProviderApiKey: string;
            rpcProvider: 'Blockfrost';
            createdAt: string;
            updatedAt: string;
            network: 'Preprod' | 'Mainnet';
        }>;
    };
};

export type GetRpcApiKeysResponse = GetRpcApiKeysResponses[keyof GetRpcApiKeysResponses];

export type ClientOptions = {
    baseURL: `${string}://${string}` | (string & {});
};